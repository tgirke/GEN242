<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>GEN242 – Tutorials</title>
    <link>/tutorials/</link>
    <description>Recent content in Tutorials on GEN242</description>
    <generator>Hugo -- gohugo.io</generator>
    
	  <atom:link href="/tutorials/index.xml" rel="self" type="application/rss+xml" />
    
    
      
        
      
    
    
    <item>
      <title>Tutorials: RNA-Seq Workflow Template</title>
      <link>/tutorials/systempiper/rnaseq/systempipernaseq/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/tutorials/systempiper/rnaseq/systempipernaseq/</guid>
      <description>
        
        
        &lt;!--
# Compile from command-line
Rscript -e &#34;rmarkdown::render(&#39;systemPipeRNAseq.Rmd&#39;, c(&#39;BiocStyle::html_document&#39;), clean=FALSE); knitr::knit(&#39;systemPipeRNAseq.Rmd&#39;, tangle=TRUE)&#34;; Rscript -e &#34;rmarkdown::render(&#39;systemPipeRNAseq.Rmd&#39;, c(&#39;BiocStyle::pdf_document&#39;))&#34;
--&gt;
&lt;style type=&#34;text/css&#34;&gt;
pre code {
white-space: pre !important;
overflow-x: scroll !important;
word-break: keep-all !important;
word-wrap: initial !important;
}
&lt;/style&gt;
&lt;script type=&#34;text/javascript&#34;&gt;
document.addEventListener(&#34;DOMContentLoaded&#34;, function() {
  document.querySelector(&#34;h1&#34;).className = &#34;title&#34;;
});
&lt;/script&gt;
&lt;script type=&#34;text/javascript&#34;&gt;
document.addEventListener(&#34;DOMContentLoaded&#34;, function() {
  var links = document.links;  
  for (var i = 0, linksLength = links.length; i &lt; linksLength; i++)
    if (links[i].hostname != window.location.hostname)
      links[i].target = &#39;_blank&#39;;
});
&lt;/script&gt;
&lt;h1 id=&#34;introduction&#34;&gt;Introduction&lt;/h1&gt;
&lt;p&gt;Users want to provide here background information about the design of their RNA-Seq project.&lt;/p&gt;
&lt;h1 id=&#34;samples-and-environment-settings&#34;&gt;Samples and environment settings&lt;/h1&gt;
&lt;h2 id=&#34;environment-settings-and-input-data&#34;&gt;Environment settings and input data&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://bioconductor.org/packages/release/data/experiment/html/systemPipeRdata.html&#34;&gt;&lt;em&gt;systemPipeRdata&lt;/em&gt;&lt;/a&gt; package is a helper package to generate a fully populated &lt;a href=&#34;http://bioconductor.org/packages/release/bioc/html/systemPipeR.html&#34;&gt;&lt;em&gt;systemPipeR&lt;/em&gt;&lt;/a&gt;
workflow environment in the current working directory with a single command.
All the instruction for generating the workflow are provide in the &lt;em&gt;systemPipeRdata&lt;/em&gt; vignette &lt;a href=&#34;http://www.bioconductor.org/packages/devel/data/experiment/vignettes/systemPipeRdata/inst/doc/systemPipeRdata.html#1_Introduction&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;systemPipeRdata::genWorkenvir(workflow = &amp;quot;rnaseq&amp;quot;, mydirname = &amp;quot;rnaseq&amp;quot;)
setwd(&amp;quot;rnaseq&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Typically, the user wants to record here the sources and versions of the
reference genome sequence along with the corresponding annotations. In
the provided sample data set all data inputs are stored in a &lt;code&gt;data&lt;/code&gt;
subdirectory and all results will be written to a separate &lt;code&gt;results&lt;/code&gt; directory,
while the &lt;code&gt;systemPipeRNAseq.Rmd&lt;/code&gt; workflow and the &lt;code&gt;targets&lt;/code&gt; file are expected to be
located in the parent directory.&lt;/p&gt;
&lt;p&gt;The chosen data set used by this report &lt;a href=&#34;http://www.ncbi.nlm.nih.gov/sra/?term=SRP010938&#34;&gt;SRP010938&lt;/a&gt;
contains 18 paired-end (PE) read sets from &lt;em&gt;Arabidposis thaliana&lt;/em&gt;
(Howard et al. 2013). To minimize processing time during testing, each FASTQ
file has been subsetted to 90,000-100,000 randomly sampled PE reads that
map to the first 100,000 nucleotides of each chromosome of the &lt;em&gt;A.
thaliana&lt;/em&gt; genome. The corresponding reference genome sequence (FASTA) and
its GFF annotation files have been truncated accordingly. This way the entire
test sample data set is less than 200MB in storage space. A PE read set has been
chosen for this test data set for flexibility, because it can be used for testing both types
of analysis routines requiring either SE (single end) reads or PE reads.&lt;/p&gt;
&lt;p&gt;To work with real data, users want to organize their own data similarly
and substitute all test data for their own data. To rerun an established
workflow on new data, the initial &lt;code&gt;targets&lt;/code&gt; file along with the corresponding
FASTQ files are usually the only inputs the user needs to provide.&lt;/p&gt;
&lt;p&gt;For more details, please consult the documentation
&lt;a href=&#34;http://www.bioconductor.org/packages/release/bioc/vignettes/systemPipeR/inst/doc/systemPipeR.html&#34;&gt;here&lt;/a&gt;. More information about the &lt;code&gt;targets&lt;/code&gt; files from &lt;em&gt;systemPipeR&lt;/em&gt; can be found &lt;a href=&#34;http://www.bioconductor.org/packages/release/bioc/vignettes/systemPipeR/inst/doc/systemPipeR.html#42_Structure_of_initial_targets_data&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id=&#34;experiment-definition-provided-by-targets-file&#34;&gt;Experiment definition provided by &lt;code&gt;targets&lt;/code&gt; file&lt;/h3&gt;
&lt;p&gt;The &lt;code&gt;targets&lt;/code&gt; file defines all FASTQ files and sample comparisons of the analysis workflow.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;targetspath &amp;lt;- system.file(&amp;quot;extdata&amp;quot;, &amp;quot;targetsPE.txt&amp;quot;, package = &amp;quot;systemPipeR&amp;quot;)
targets &amp;lt;- read.delim(targetspath, comment.char = &amp;quot;#&amp;quot;)
targets[1:4, -c(5, 6)]
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##                     FileName1                   FileName2
## 1 ./data/SRR446027_1.fastq.gz ./data/SRR446027_2.fastq.gz
## 2 ./data/SRR446028_1.fastq.gz ./data/SRR446028_2.fastq.gz
## 3 ./data/SRR446029_1.fastq.gz ./data/SRR446029_2.fastq.gz
## 4 ./data/SRR446030_1.fastq.gz ./data/SRR446030_2.fastq.gz
##   SampleName Factor        Date
## 1        M1A     M1 23-Mar-2012
## 2        M1B     M1 23-Mar-2012
## 3        A1A     A1 23-Mar-2012
## 4        A1B     A1 23-Mar-2012
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To work with custom data, users need to generate a &lt;em&gt;&lt;code&gt;targets&lt;/code&gt;&lt;/em&gt; file containing
the paths to their own FASTQ files.&lt;/p&gt;
&lt;h1 id=&#34;workflow-environment&#34;&gt;Workflow environment&lt;/h1&gt;
&lt;p&gt;&lt;em&gt;&lt;code&gt;systemPipeR&lt;/code&gt;&lt;/em&gt; workflows can be designed and built from start to finish with a
single command, importing from an R Markdown file or stepwise in interactive
mode from the R console.&lt;/p&gt;
&lt;p&gt;This tutorial will demonstrate how to build the workflow in an interactive mode,
appending each step. The workflow is constructed by connecting each step via
&lt;code&gt;appendStep&lt;/code&gt; method. Each &lt;code&gt;SYSargsList&lt;/code&gt; instance contains instructions for
processing a set of input files with a specific command-line or R software
and the paths to the corresponding outfiles generated by a particular command-line
software/step.&lt;/p&gt;
&lt;p&gt;To create a workflow within &lt;em&gt;&lt;code&gt;systemPipeR&lt;/code&gt;&lt;/em&gt;, we can start by defining an empty
container and checking the directory structure:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(systemPipeR)
sal &amp;lt;- SPRproject()
sal
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;required-packages-and-resources&#34;&gt;Required packages and resources&lt;/h2&gt;
&lt;p&gt;The &lt;code&gt;systemPipeR&lt;/code&gt; package needs to be loaded (H Backman and Girke 2016).&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;appendStep(sal) &amp;lt;- LineWise(code = {
    library(systemPipeR)
}, step_name = &amp;quot;load_SPR&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;read-preprocessing&#34;&gt;Read preprocessing&lt;/h2&gt;
&lt;h3 id=&#34;preprocessing-with-preprocessreads-function&#34;&gt;Preprocessing with &lt;code&gt;preprocessReads&lt;/code&gt; function&lt;/h3&gt;
&lt;p&gt;The function &lt;code&gt;preprocessReads&lt;/code&gt; allows to apply predefined or custom
read preprocessing functions to all FASTQ files referenced in a
&lt;code&gt;SYSargsList&lt;/code&gt; container, such as quality filtering or adapter trimming
routines. Internally, &lt;code&gt;preprocessReads&lt;/code&gt; uses the &lt;code&gt;FastqStreamer&lt;/code&gt; function from
the &lt;code&gt;ShortRead&lt;/code&gt; package to stream through large FASTQ files in a
memory-efficient manner. The following example performs adapter trimming with
the &lt;code&gt;trimLRPatterns&lt;/code&gt; function from the &lt;code&gt;Biostrings&lt;/code&gt; package.&lt;/p&gt;
&lt;p&gt;Here, we are appending this step to the &lt;code&gt;SYSargsList&lt;/code&gt; object created previously.
All the parameters are defined on the &lt;code&gt;preprocessReads/preprocessReads-pe.yml&lt;/code&gt; file.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;appendStep(sal) &amp;lt;- SYSargsList(step_name = &amp;quot;preprocessing&amp;quot;, targets = &amp;quot;targetsPE.txt&amp;quot;,
    dir = TRUE, wf_file = &amp;quot;preprocessReads/preprocessReads-pe.cwl&amp;quot;,
    input_file = &amp;quot;preprocessReads/preprocessReads-pe.yml&amp;quot;, dir_path = system.file(&amp;quot;extdata/cwl&amp;quot;,
        package = &amp;quot;systemPipeR&amp;quot;), inputvars = c(FileName1 = &amp;quot;_FASTQ_PATH1_&amp;quot;,
        FileName2 = &amp;quot;_FASTQ_PATH2_&amp;quot;, SampleName = &amp;quot;_SampleName_&amp;quot;),
    dependency = c(&amp;quot;load_SPR&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the preprocessing step, the &lt;code&gt;outfiles&lt;/code&gt; files can be used to generate the new
targets files containing the paths to the trimmed FASTQ files. The new targets
information can be used for the next workflow step instance, &lt;em&gt;e.g.&lt;/em&gt; running the
NGS alignments with the trimmed FASTQ files. The &lt;code&gt;appendStep&lt;/code&gt; function is
automatically handling this connectivity between steps. Please check the next
step for more details.&lt;/p&gt;
&lt;p&gt;The following example shows how one can design a custom read &lt;em&gt;‘preprocessReads’&lt;/em&gt;
function using utilities provided by the &lt;code&gt;ShortRead&lt;/code&gt; package, and then run it
in batch mode with the &lt;em&gt;‘preprocessReads’&lt;/em&gt; function. Here, it is possible to
replace the function used on the &lt;code&gt;preprocessing&lt;/code&gt; step and modify the &lt;code&gt;sal&lt;/code&gt; object.
Because it is a custom function, it is necessary to save the part in the R object,
and internally the &lt;code&gt;preprocessReads.doc.R&lt;/code&gt; is loading the custom function.
If the R object is saved with a different name (here &lt;code&gt;&amp;quot;param/customFCT.RData&amp;quot;&lt;/code&gt;),
please replace that accordingly in the &lt;code&gt;preprocessReads.doc.R&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Please, note that this step is not added to the workflow, here just for
demonstration.&lt;/p&gt;
&lt;p&gt;First, we defined the custom function in the workflow:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;appendStep(sal) &amp;lt;- LineWise(code = {
    filterFct &amp;lt;- function(fq, cutoff = 20, Nexceptions = 0) {
        qcount &amp;lt;- rowSums(as(quality(fq), &amp;quot;matrix&amp;quot;) &amp;lt;= cutoff,
            na.rm = TRUE)
        # Retains reads where Phred scores are &amp;gt;= cutoff
        # with N exceptions
        fq[qcount &amp;lt;= Nexceptions]
    }
    save(list = ls(), file = &amp;quot;param/customFCT.RData&amp;quot;)
}, step_name = &amp;quot;custom_preprocessing_function&amp;quot;, dependency = &amp;quot;preprocessing&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After, we can edit the input parameter:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;yamlinput(sal, &amp;quot;preprocessing&amp;quot;)$Fct
yamlinput(sal, &amp;quot;preprocessing&amp;quot;, &amp;quot;Fct&amp;quot;) &amp;lt;- &amp;quot;&#39;filterFct(fq, cutoff=20, Nexceptions=0)&#39;&amp;quot;
yamlinput(sal, &amp;quot;preprocessing&amp;quot;)$Fct  ## check the new function
cmdlist(sal, &amp;quot;preprocessing&amp;quot;, targets = 1)  ## check if the command line was updated with success
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;read-trimming-with-trimmomatic&#34;&gt;Read trimming with Trimmomatic&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;http://www.usadellab.org/cms/?page=trimmomatic&#34;&gt;Trimmomatic&lt;/a&gt; software (Bolger, Lohse, and Usadel 2014)
performs a variety of useful trimming tasks for Illumina paired-end and single
ended data. Here, an example of how to perform this task using parameters template
files for trimming FASTQ files.&lt;/p&gt;
&lt;p&gt;This step is optional.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;appendStep(sal) &amp;lt;- SYSargsList(step_name = &amp;quot;trimming&amp;quot;, targets = &amp;quot;targetsPE.txt&amp;quot;,
    wf_file = &amp;quot;trimmomatic/trimmomatic-pe.cwl&amp;quot;, input_file = &amp;quot;trimmomatic/trimmomatic-pe.yml&amp;quot;,
    dir_path = system.file(&amp;quot;extdata/cwl&amp;quot;, package = &amp;quot;systemPipeR&amp;quot;),
    inputvars = c(FileName1 = &amp;quot;_FASTQ_PATH1_&amp;quot;, FileName2 = &amp;quot;_FASTQ_PATH2_&amp;quot;,
        SampleName = &amp;quot;_SampleName_&amp;quot;), dependency = &amp;quot;load_SPR&amp;quot;,
    run_step = &amp;quot;optional&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;fastq-quality-report&#34;&gt;FASTQ quality report&lt;/h3&gt;
&lt;p&gt;The following &lt;code&gt;seeFastq&lt;/code&gt; and &lt;code&gt;seeFastqPlot&lt;/code&gt; functions generate and plot a series of useful
quality statistics for a set of FASTQ files, including per cycle quality box
plots, base proportions, base-level quality trends, relative k-mer
diversity, length, and occurrence distribution of reads, number of reads
above quality cutoffs and mean quality distribution. The results are
written to a png file named &lt;code&gt;fastqReport.png&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;appendStep(sal) &amp;lt;- LineWise(code = {
    fastq &amp;lt;- getColumn(sal, step = &amp;quot;preprocessing&amp;quot;, &amp;quot;targetsWF&amp;quot;,
        column = 1)
    fqlist &amp;lt;- seeFastq(fastq = fastq, batchsize = 10000, klength = 8)
    png(&amp;quot;./results/fastqReport.png&amp;quot;, height = 162, width = 288 *
        length(fqlist))
    seeFastqPlot(fqlist)
    dev.off()
}, step_name = &amp;quot;fastq_report&amp;quot;, dependency = &amp;quot;preprocessing&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;results/fastqReport.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;div data-align=&#34;center&#34;&gt;
&lt;p&gt;Figure 1: FASTQ quality report for 18 samples&lt;/p&gt;
&lt;/div&gt;
&lt;/br&gt;
&lt;h2 id=&#34;alignments&#34;&gt;Alignments&lt;/h2&gt;
&lt;h3 id=&#34;read-mapping-with-hisat2&#34;&gt;Read mapping with &lt;code&gt;HISAT2&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;The following steps will demonstrate how to use the short read aligner &lt;code&gt;Hisat2&lt;/code&gt;
(Kim, Langmead, and Salzberg 2015). First, the &lt;code&gt;Hisat2&lt;/code&gt; index needs to be created.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;appendStep(sal) &amp;lt;- SYSargsList(step_name = &amp;quot;hisat2_index&amp;quot;, dir = FALSE,
    targets = NULL, wf_file = &amp;quot;hisat2/hisat2-index.cwl&amp;quot;, input_file = &amp;quot;hisat2/hisat2-index.yml&amp;quot;,
    dir_path = &amp;quot;param/cwl&amp;quot;, dependency = &amp;quot;load_SPR&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;hisat2-mapping&#34;&gt;&lt;code&gt;HISAT2&lt;/code&gt; mapping&lt;/h3&gt;
&lt;p&gt;The parameter settings of the aligner are defined in the &lt;code&gt;workflow_hisat2-pe.cwl&lt;/code&gt;
and &lt;code&gt;workflow_hisat2-pe.yml&lt;/code&gt; files. The following shows how to construct the
corresponding &lt;em&gt;SYSargsList&lt;/em&gt; object.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;appendStep(sal) &amp;lt;- SYSargsList(step_name = &amp;quot;hisat2_mapping&amp;quot;,
    dir = TRUE, targets = &amp;quot;preprocessing&amp;quot;, wf_file = &amp;quot;workflow-hisat2/workflow_hisat2-pe.cwl&amp;quot;,
    input_file = &amp;quot;workflow-hisat2/workflow_hisat2-pe.yml&amp;quot;, dir_path = &amp;quot;param/cwl&amp;quot;,
    inputvars = c(preprocessReads_1 = &amp;quot;_FASTQ_PATH1_&amp;quot;, preprocessReads_2 = &amp;quot;_FASTQ_PATH2_&amp;quot;,
        SampleName = &amp;quot;_SampleName_&amp;quot;), rm_targets_col = c(&amp;quot;FileName1&amp;quot;,
        &amp;quot;FileName2&amp;quot;), dependency = c(&amp;quot;preprocessing&amp;quot;, &amp;quot;hisat2_index&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To double-check the command line for each sample, please use the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;cmdlist(sal, step = &amp;quot;hisat2_mapping&amp;quot;, targets = 1)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;read-and-alignment-stats&#34;&gt;Read and alignment stats&lt;/h3&gt;
&lt;p&gt;The following provides an overview of the number of reads in each sample
and how many of them aligned to the reference.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;appendStep(sal) &amp;lt;- LineWise(code = {
    fqpaths &amp;lt;- getColumn(sal, step = &amp;quot;preprocessing&amp;quot;, &amp;quot;targetsWF&amp;quot;,
        column = &amp;quot;FileName1&amp;quot;)
    bampaths &amp;lt;- getColumn(sal, step = &amp;quot;hisat2_mapping&amp;quot;, &amp;quot;outfiles&amp;quot;,
        column = &amp;quot;samtools_sort_bam&amp;quot;)
    read_statsDF &amp;lt;- alignStats(args = bampaths, fqpaths = fqpaths,
        pairEnd = TRUE)
    write.table(read_statsDF, &amp;quot;results/alignStats.xls&amp;quot;, row.names = FALSE,
        quote = FALSE, sep = &amp;quot;\t&amp;quot;)
}, step_name = &amp;quot;align_stats&amp;quot;, dependency = &amp;quot;hisat2_mapping&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;create-symbolic-links-for-viewing-bam-files-in-igv&#34;&gt;Create symbolic links for viewing BAM files in IGV&lt;/h2&gt;
&lt;p&gt;The &lt;code&gt;symLink2bam&lt;/code&gt; function creates symbolic links to view the BAM alignment files in a
genome browser such as IGV without moving these large files to a local
system. The corresponding URLs are written to a file with a path
specified under &lt;code&gt;urlfile&lt;/code&gt;, here &lt;code&gt;IGVurl.txt&lt;/code&gt;.
Please replace the directory and the user name.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;appendStep(sal) &amp;lt;- LineWise(code = {
    bampaths &amp;lt;- getColumn(sal, step = &amp;quot;hisat2_mapping&amp;quot;, &amp;quot;outfiles&amp;quot;,
        column = &amp;quot;samtools_sort_bam&amp;quot;)
    symLink2bam(sysargs = bampaths, htmldir = c(&amp;quot;~/.html/&amp;quot;, &amp;quot;somedir/&amp;quot;),
        urlbase = &amp;quot;http://cluster.hpcc.ucr.edu/~tgirke/&amp;quot;, urlfile = &amp;quot;./results/IGVurl.txt&amp;quot;)
}, step_name = &amp;quot;bam_IGV&amp;quot;, dependency = &amp;quot;hisat2_mapping&amp;quot;, run_step = &amp;quot;optional&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;read-quantification&#34;&gt;Read quantification&lt;/h2&gt;
&lt;p&gt;Reads overlapping with annotation ranges of interest are counted for
each sample using the &lt;code&gt;summarizeOverlaps&lt;/code&gt; function (Lawrence et al. 2013).
The read counting is preformed for exon gene regions in a non-strand-specific
manner while ignoring overlaps among different genes. Subsequently, the expression
count values are normalized by &lt;em&gt;reads per kp per million mapped reads&lt;/em&gt;
(RPKM). The raw read count table (&lt;code&gt;countDFeByg.xls&lt;/code&gt;) and the corresponding
RPKM table (&lt;code&gt;rpkmDFeByg.xls&lt;/code&gt;) are written to separate files in the directory of
this project. Parallelization is achieved with the &lt;code&gt;BiocParallel&lt;/code&gt; package,
here using 4 CPU cores.&lt;/p&gt;
&lt;h3 id=&#34;create-a-database-for-gene-annotation&#34;&gt;Create a database for gene annotation&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;appendStep(sal) &amp;lt;- LineWise(code = {
    library(GenomicFeatures)
    txdb &amp;lt;- suppressWarnings(makeTxDbFromGFF(file = &amp;quot;data/tair10.gff&amp;quot;,
        format = &amp;quot;gff&amp;quot;, dataSource = &amp;quot;TAIR&amp;quot;, organism = &amp;quot;Arabidopsis thaliana&amp;quot;))
    saveDb(txdb, file = &amp;quot;./data/tair10.sqlite&amp;quot;)
}, step_name = &amp;quot;create_db&amp;quot;, dependency = &amp;quot;hisat2_mapping&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;read-counting-with-summarizeoverlaps-in-parallel-mode-using-multiple-cores&#34;&gt;Read counting with &lt;code&gt;summarizeOverlaps&lt;/code&gt; in parallel mode using multiple cores&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;appendStep(sal) &amp;lt;- LineWise(code = {
    library(GenomicFeatures)
    library(BiocParallel)
    txdb &amp;lt;- loadDb(&amp;quot;./data/tair10.sqlite&amp;quot;)
    outpaths &amp;lt;- getColumn(sal, step = &amp;quot;hisat2_mapping&amp;quot;, &amp;quot;outfiles&amp;quot;,
        column = &amp;quot;samtools_sort_bam&amp;quot;)
    eByg &amp;lt;- exonsBy(txdb, by = c(&amp;quot;gene&amp;quot;))
    bfl &amp;lt;- BamFileList(outpaths, yieldSize = 50000, index = character())
    multicoreParam &amp;lt;- MulticoreParam(workers = 4)
    register(multicoreParam)
    registered()
    counteByg &amp;lt;- bplapply(bfl, function(x) summarizeOverlaps(eByg,
        x, mode = &amp;quot;Union&amp;quot;, ignore.strand = TRUE, inter.feature = FALSE,
        singleEnd = FALSE, BPPARAM = multicoreParam))
    countDFeByg &amp;lt;- sapply(seq(along = counteByg), function(x) assays(counteByg[[x]])$counts)
    rownames(countDFeByg) &amp;lt;- names(rowRanges(counteByg[[1]]))
    colnames(countDFeByg) &amp;lt;- names(bfl)
    rpkmDFeByg &amp;lt;- apply(countDFeByg, 2, function(x) returnRPKM(counts = x,
        ranges = eByg))
    write.table(countDFeByg, &amp;quot;results/countDFeByg.xls&amp;quot;, col.names = NA,
        quote = FALSE, sep = &amp;quot;\t&amp;quot;)
    write.table(rpkmDFeByg, &amp;quot;results/rpkmDFeByg.xls&amp;quot;, col.names = NA,
        quote = FALSE, sep = &amp;quot;\t&amp;quot;)
    ## Creating a SummarizedExperiment object
    colData &amp;lt;- data.frame(row.names = SampleName(sal, &amp;quot;hisat2_mapping&amp;quot;),
        condition = getColumn(sal, &amp;quot;hisat2_mapping&amp;quot;, position = &amp;quot;targetsWF&amp;quot;,
            column = &amp;quot;Factor&amp;quot;))
    colData$condition &amp;lt;- factor(colData$condition)
    countDF_se &amp;lt;- SummarizedExperiment::SummarizedExperiment(assays = countDFeByg,
        colData = colData)
    ## Add results as SummarizedExperiment to the workflow
    ## object
    SE(sal, &amp;quot;read_counting&amp;quot;) &amp;lt;- countDF_se
}, step_name = &amp;quot;read_counting&amp;quot;, dependency = &amp;quot;create_db&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When providing a &lt;code&gt;BamFileList&lt;/code&gt; as in the example above, &lt;code&gt;summarizeOverlaps&lt;/code&gt; methods
use by default &lt;code&gt;bplapply&lt;/code&gt; and use the register interface from BiocParallel package.
If the number of workers is not set, &lt;code&gt;MulticoreParam&lt;/code&gt; will use the number of cores
returned by &lt;code&gt;parallel::detectCores()&lt;/code&gt;. For more information,
please check &lt;code&gt;help(&amp;quot;summarizeOverlaps&amp;quot;)&lt;/code&gt; documentation.&lt;/p&gt;
&lt;p&gt;Note, for most statistical differential expression or abundance analysis
methods, such as &lt;code&gt;edgeR&lt;/code&gt; or &lt;code&gt;DESeq2&lt;/code&gt;, the raw count values should be used as input. The
usage of RPKM values should be restricted to specialty applications
required by some users, &lt;em&gt;e.g.&lt;/em&gt; manually comparing the expression levels
among different genes or features.&lt;/p&gt;
&lt;h3 id=&#34;sample-wise-correlation-analysis&#34;&gt;Sample-wise correlation analysis&lt;/h3&gt;
&lt;p&gt;The following computes the sample-wise Spearman correlation coefficients from
the &lt;code&gt;rlog&lt;/code&gt; transformed expression values generated with the &lt;code&gt;DESeq2&lt;/code&gt; package. After
transformation to a distance matrix, hierarchical clustering is performed with
the &lt;code&gt;hclust&lt;/code&gt; function and the result is plotted as a dendrogram
(also see file &lt;code&gt;sample_tree.png&lt;/code&gt;).&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;appendStep(sal) &amp;lt;- LineWise(code = {
    library(DESeq2, quietly = TRUE)
    library(ape, warn.conflicts = FALSE)
    ## Extracting SummarizedExperiment object
    se &amp;lt;- SE(sal, &amp;quot;read_counting&amp;quot;)
    dds &amp;lt;- DESeqDataSet(se, design = ~condition)
    d &amp;lt;- cor(assay(rlog(dds)), method = &amp;quot;spearman&amp;quot;)
    hc &amp;lt;- hclust(dist(1 - d))
    png(&amp;quot;results/sample_tree.png&amp;quot;)
    plot.phylo(as.phylo(hc), type = &amp;quot;p&amp;quot;, edge.col = &amp;quot;blue&amp;quot;, edge.width = 2,
        show.node.label = TRUE, no.margin = TRUE)
    dev.off()
}, step_name = &amp;quot;sample_tree&amp;quot;, dependency = &amp;quot;read_counting&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;results/sample_tree.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;div data-align=&#34;center&#34;&gt;
&lt;p&gt;Figure 2: Correlation dendrogram of samples&lt;/p&gt;
&lt;/div&gt;
&lt;/br&gt;
&lt;h2 id=&#34;analysis-of-degs&#34;&gt;Analysis of DEGs&lt;/h2&gt;
&lt;p&gt;The analysis of differentially expressed genes (DEGs) is performed with
the &lt;code&gt;glm&lt;/code&gt; method of the &lt;code&gt;edgeR&lt;/code&gt; package (Robinson, McCarthy, and Smyth 2010). The sample
comparisons used by this analysis are defined in the header lines of the
&lt;code&gt;targets.txt&lt;/code&gt; file starting with &lt;code&gt;&amp;lt;CMP&amp;gt;&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id=&#34;run-edger&#34;&gt;Run &lt;code&gt;edgeR&lt;/code&gt;&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;appendStep(sal) &amp;lt;- LineWise(code = {
    library(edgeR)
    countDF &amp;lt;- read.delim(&amp;quot;results/countDFeByg.xls&amp;quot;, row.names = 1,
        check.names = FALSE)
    cmp &amp;lt;- readComp(stepsWF(sal)[[&amp;quot;hisat2_mapping&amp;quot;]], format = &amp;quot;matrix&amp;quot;,
        delim = &amp;quot;-&amp;quot;)
    edgeDF &amp;lt;- run_edgeR(countDF = countDF, targets = targetsWF(sal)[[&amp;quot;hisat2_mapping&amp;quot;]],
        cmp = cmp[[1]], independent = FALSE, mdsplot = &amp;quot;&amp;quot;)
}, step_name = &amp;quot;run_edger&amp;quot;, dependency = &amp;quot;read_counting&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;add-gene-descriptions&#34;&gt;Add gene descriptions&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;appendStep(sal) &amp;lt;- LineWise(code = {
    library(&amp;quot;biomaRt&amp;quot;)
    m &amp;lt;- useMart(&amp;quot;plants_mart&amp;quot;, dataset = &amp;quot;athaliana_eg_gene&amp;quot;,
        host = &amp;quot;https://plants.ensembl.org&amp;quot;)
    desc &amp;lt;- getBM(attributes = c(&amp;quot;tair_locus&amp;quot;, &amp;quot;description&amp;quot;),
        mart = m)
    desc &amp;lt;- desc[!duplicated(desc[, 1]), ]
    descv &amp;lt;- as.character(desc[, 2])
    names(descv) &amp;lt;- as.character(desc[, 1])
    edgeDF &amp;lt;- data.frame(edgeDF, Desc = descv[rownames(edgeDF)],
        check.names = FALSE)
    write.table(edgeDF, &amp;quot;./results/edgeRglm_allcomp.xls&amp;quot;, quote = FALSE,
        sep = &amp;quot;\t&amp;quot;, col.names = NA)
}, step_name = &amp;quot;custom_annot&amp;quot;, dependency = &amp;quot;run_edger&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;plot-deg-results&#34;&gt;Plot DEG results&lt;/h3&gt;
&lt;p&gt;Filter and plot DEG results for up and down regulated genes. The
definition of &lt;em&gt;up&lt;/em&gt; and &lt;em&gt;down&lt;/em&gt; is given in the corresponding help
file. To open it, type &lt;code&gt;?filterDEGs&lt;/code&gt; in the R console.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;appendStep(sal) &amp;lt;- LineWise(code = {
    edgeDF &amp;lt;- read.delim(&amp;quot;results/edgeRglm_allcomp.xls&amp;quot;, row.names = 1,
        check.names = FALSE)
    png(&amp;quot;results/DEGcounts.png&amp;quot;)
    DEG_list &amp;lt;- filterDEGs(degDF = edgeDF, filter = c(Fold = 2,
        FDR = 20))
    dev.off()
    write.table(DEG_list$Summary, &amp;quot;./results/DEGcounts.xls&amp;quot;,
        quote = FALSE, sep = &amp;quot;\t&amp;quot;, row.names = FALSE)
}, step_name = &amp;quot;filter_degs&amp;quot;, dependency = &amp;quot;custom_annot&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;venn-diagrams-of-deg-sets&#34;&gt;Venn diagrams of DEG sets&lt;/h3&gt;
&lt;p&gt;The &lt;code&gt;overLapper&lt;/code&gt; function can compute Venn intersects for large numbers of sample
sets (up to 20 or more) and plots 2-5 way Venn diagrams. A useful
feature is the possibility to combine the counts from several Venn
comparisons with the same number of sample sets in a single Venn diagram
(here for 4 up and down DEG sets).&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;appendStep(sal) &amp;lt;- LineWise(code = {
    vennsetup &amp;lt;- overLapper(DEG_list$Up[6:9], type = &amp;quot;vennsets&amp;quot;)
    vennsetdown &amp;lt;- overLapper(DEG_list$Down[6:9], type = &amp;quot;vennsets&amp;quot;)
    png(&amp;quot;results/vennplot.png&amp;quot;)
    vennPlot(list(vennsetup, vennsetdown), mymain = &amp;quot;&amp;quot;, mysub = &amp;quot;&amp;quot;,
        colmode = 2, ccol = c(&amp;quot;blue&amp;quot;, &amp;quot;red&amp;quot;))
    dev.off()
}, step_name = &amp;quot;venn_diagram&amp;quot;, dependency = &amp;quot;filter_degs&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;go-term-enrichment-analysis&#34;&gt;GO term enrichment analysis&lt;/h2&gt;
&lt;h3 id=&#34;obtain-gene-to-go-mappings&#34;&gt;Obtain gene-to-GO mappings&lt;/h3&gt;
&lt;p&gt;The following shows how to obtain gene-to-GO mappings from &lt;code&gt;biomaRt&lt;/code&gt; (here for &lt;em&gt;A.
thaliana&lt;/em&gt;) and how to organize them for the downstream GO term
enrichment analysis. Alternatively, the gene-to-GO mappings can be
obtained for many organisms from Bioconductor’s &lt;code&gt;*.db&lt;/code&gt; genome annotation
packages or GO annotation files provided by various genome databases.
For each annotation this relatively slow preprocessing step needs to be
performed only once. Subsequently, the preprocessed data can be loaded
with the &lt;code&gt;load&lt;/code&gt; function as shown in the next subsection.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;appendStep(sal) &amp;lt;- LineWise(code = {
    library(&amp;quot;biomaRt&amp;quot;)
    # listMarts() # To choose BioMart database
    # listMarts(host=&#39;plants.ensembl.org&#39;)
    m &amp;lt;- useMart(&amp;quot;plants_mart&amp;quot;, host = &amp;quot;https://plants.ensembl.org&amp;quot;)
    # listDatasets(m)
    m &amp;lt;- useMart(&amp;quot;plants_mart&amp;quot;, dataset = &amp;quot;athaliana_eg_gene&amp;quot;,
        host = &amp;quot;https://plants.ensembl.org&amp;quot;)
    # listAttributes(m) # Choose data types you want to
    # download
    go &amp;lt;- getBM(attributes = c(&amp;quot;go_id&amp;quot;, &amp;quot;tair_locus&amp;quot;, &amp;quot;namespace_1003&amp;quot;),
        mart = m)
    go &amp;lt;- go[go[, 3] != &amp;quot;&amp;quot;, ]
    go[, 3] &amp;lt;- as.character(go[, 3])
    go[go[, 3] == &amp;quot;molecular_function&amp;quot;, 3] &amp;lt;- &amp;quot;F&amp;quot;
    go[go[, 3] == &amp;quot;biological_process&amp;quot;, 3] &amp;lt;- &amp;quot;P&amp;quot;
    go[go[, 3] == &amp;quot;cellular_component&amp;quot;, 3] &amp;lt;- &amp;quot;C&amp;quot;
    go[1:4, ]
    if (!dir.exists(&amp;quot;./data/GO&amp;quot;))
        dir.create(&amp;quot;./data/GO&amp;quot;)
    write.table(go, &amp;quot;data/GO/GOannotationsBiomart_mod.txt&amp;quot;, quote = FALSE,
        row.names = FALSE, col.names = FALSE, sep = &amp;quot;\t&amp;quot;)
    catdb &amp;lt;- makeCATdb(myfile = &amp;quot;data/GO/GOannotationsBiomart_mod.txt&amp;quot;,
        lib = NULL, org = &amp;quot;&amp;quot;, colno = c(1, 2, 3), idconv = NULL)
    save(catdb, file = &amp;quot;data/GO/catdb.RData&amp;quot;)
}, step_name = &amp;quot;get_go_annot&amp;quot;, dependency = &amp;quot;filter_degs&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;batch-go-term-enrichment-analysis&#34;&gt;Batch GO term enrichment analysis&lt;/h3&gt;
&lt;p&gt;Apply the enrichment analysis to the DEG sets obtained the above differential
expression analysis. Note, in the following example the &lt;code&gt;FDR&lt;/code&gt; filter is set
here to an unreasonably high value, simply because of the small size of the toy
data set used in this vignette. Batch enrichment analysis of many gene sets is
performed with the function. When &lt;code&gt;method=all&lt;/code&gt;, it returns all GO terms passing
the p-value cutoff specified under the &lt;code&gt;cutoff&lt;/code&gt; arguments. When &lt;code&gt;method=slim&lt;/code&gt;,
it returns only the GO terms specified under the &lt;code&gt;myslimv&lt;/code&gt; argument. The given
example shows how a GO slim vector for a specific organism can be obtained from
&lt;code&gt;BioMart&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;appendStep(sal) &amp;lt;- LineWise(code = {
    library(&amp;quot;biomaRt&amp;quot;)
    load(&amp;quot;data/GO/catdb.RData&amp;quot;)
    DEG_list &amp;lt;- filterDEGs(degDF = edgeDF, filter = c(Fold = 2,
        FDR = 50), plot = FALSE)
    up_down &amp;lt;- DEG_list$UporDown
    names(up_down) &amp;lt;- paste(names(up_down), &amp;quot;_up_down&amp;quot;, sep = &amp;quot;&amp;quot;)
    up &amp;lt;- DEG_list$Up
    names(up) &amp;lt;- paste(names(up), &amp;quot;_up&amp;quot;, sep = &amp;quot;&amp;quot;)
    down &amp;lt;- DEG_list$Down
    names(down) &amp;lt;- paste(names(down), &amp;quot;_down&amp;quot;, sep = &amp;quot;&amp;quot;)
    DEGlist &amp;lt;- c(up_down, up, down)
    DEGlist &amp;lt;- DEGlist[sapply(DEGlist, length) &amp;gt; 0]
    BatchResult &amp;lt;- GOCluster_Report(catdb = catdb, setlist = DEGlist,
        method = &amp;quot;all&amp;quot;, id_type = &amp;quot;gene&amp;quot;, CLSZ = 2, cutoff = 0.9,
        gocats = c(&amp;quot;MF&amp;quot;, &amp;quot;BP&amp;quot;, &amp;quot;CC&amp;quot;), recordSpecGO = NULL)
    m &amp;lt;- useMart(&amp;quot;plants_mart&amp;quot;, dataset = &amp;quot;athaliana_eg_gene&amp;quot;,
        host = &amp;quot;https://plants.ensembl.org&amp;quot;)
    goslimvec &amp;lt;- as.character(getBM(attributes = c(&amp;quot;goslim_goa_accession&amp;quot;),
        mart = m)[, 1])
    BatchResultslim &amp;lt;- GOCluster_Report(catdb = catdb, setlist = DEGlist,
        method = &amp;quot;slim&amp;quot;, id_type = &amp;quot;gene&amp;quot;, myslimv = goslimvec,
        CLSZ = 10, cutoff = 0.01, gocats = c(&amp;quot;MF&amp;quot;, &amp;quot;BP&amp;quot;, &amp;quot;CC&amp;quot;),
        recordSpecGO = NULL)
    write.table(BatchResultslim, &amp;quot;results/GOBatchSlim.xls&amp;quot;, row.names = FALSE,
        quote = FALSE, sep = &amp;quot;\t&amp;quot;)
}, step_name = &amp;quot;go_enrich&amp;quot;, dependency = &amp;quot;get_go_annot&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;plot-batch-go-term-results&#34;&gt;Plot batch GO term results&lt;/h3&gt;
&lt;p&gt;The &lt;code&gt;data.frame&lt;/code&gt; generated by &lt;code&gt;GOCluster&lt;/code&gt; can be plotted with the &lt;code&gt;goBarplot&lt;/code&gt; function. Because of the
variable size of the sample sets, it may not always be desirable to show
the results from different DEG sets in the same bar plot. Plotting
single sample sets is achieved by subsetting the input data frame as
shown in the first line of the following example.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;appendStep(sal) &amp;lt;- LineWise(code = {
    gos &amp;lt;- BatchResultslim[grep(&amp;quot;M6-V6_up_down&amp;quot;, BatchResultslim$CLID),
        ]
    gos &amp;lt;- BatchResultslim
    png(&amp;quot;results/GOslimbarplotMF.png&amp;quot;, height = 8, width = 10)
    goBarplot(gos, gocat = &amp;quot;MF&amp;quot;)
    goBarplot(gos, gocat = &amp;quot;BP&amp;quot;)
    goBarplot(gos, gocat = &amp;quot;CC&amp;quot;)
    dev.off()
}, step_name = &amp;quot;go_plot&amp;quot;, dependency = &amp;quot;go_enrich&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;results/GOslimbarplotMF.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;div data-align=&#34;center&#34;&gt;
&lt;p&gt;Figure 5: GO Slim Barplot for MF Ontology&lt;/p&gt;
&lt;/div&gt;
&lt;/br&gt;
&lt;h2 id=&#34;clustering-and-heat-maps&#34;&gt;Clustering and heat maps&lt;/h2&gt;
&lt;p&gt;The following example performs hierarchical clustering on the &lt;code&gt;rlog&lt;/code&gt;
transformed expression matrix subsetted by the DEGs identified in the above
differential expression analysis. It uses a Pearson correlation-based distance
measure and complete linkage for cluster joining.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;appendStep(sal) &amp;lt;- LineWise(code = {
    library(pheatmap)
    geneids &amp;lt;- unique(as.character(unlist(DEG_list[[1]])))
    y &amp;lt;- assay(rlog(dds))[geneids, ]
    png(&amp;quot;results/heatmap1.png&amp;quot;)
    pheatmap(y, scale = &amp;quot;row&amp;quot;, clustering_distance_rows = &amp;quot;correlation&amp;quot;,
        clustering_distance_cols = &amp;quot;correlation&amp;quot;)
    dev.off()
}, step_name = &amp;quot;heatmap&amp;quot;, dependency = &amp;quot;go_enrich&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;results/heatmap1.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;div data-align=&#34;center&#34;&gt;
&lt;p&gt;Figure 6: Heat Map with Hierarchical Clustering Dendrograms of DEGs&lt;/p&gt;
&lt;/div&gt;
&lt;/br&gt;
&lt;h2 id=&#34;version-information&#34;&gt;Version Information&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;appendStep(sal) &amp;lt;- LineWise(code = {
    sessionInfo()
}, step_name = &amp;quot;sessionInfo&amp;quot;, dependency = &amp;quot;heatmap&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;running-workflow&#34;&gt;Running workflow&lt;/h1&gt;
&lt;h2 id=&#34;interactive-job-submissions-in-a-single-machine&#34;&gt;Interactive job submissions in a single machine&lt;/h2&gt;
&lt;p&gt;For running the workflow, &lt;code&gt;runWF&lt;/code&gt; function will execute all the steps store in
the workflow container. The execution will be on a single machine without
submitting to a queuing system of a computer cluster.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;sal &amp;lt;- runWF(sal)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;parallelization-on-clusters&#34;&gt;Parallelization on clusters&lt;/h2&gt;
&lt;p&gt;Alternatively, the computation can be greatly accelerated by processing many files
in parallel using several compute nodes of a cluster, where a scheduling/queuing
system is used for load balancing.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;resources&lt;/code&gt; list object provides the number of independent parallel cluster
processes defined under the &lt;code&gt;Njobs&lt;/code&gt; element in the list. The following example
will run 18 processes in parallel using each 4 CPU cores.
If the resources available on a cluster allow running all 18 processes at the
same time, then the shown sample submission will utilize in a total of 72 CPU cores.&lt;/p&gt;
&lt;p&gt;Note, &lt;code&gt;runWF&lt;/code&gt; can be used with most queueing systems as it is based on utilities
from the &lt;code&gt;batchtools&lt;/code&gt; package, which supports the use of template files (&lt;em&gt;&lt;code&gt;*.tmpl&lt;/code&gt;&lt;/em&gt;)
for defining the run parameters of different schedulers. To run the following
code, one needs to have both a &lt;code&gt;conffile&lt;/code&gt; (see &lt;em&gt;&lt;code&gt;.batchtools.conf.R&lt;/code&gt;&lt;/em&gt; samples &lt;a href=&#34;https://mllg.github.io/batchtools/&#34;&gt;here&lt;/a&gt;)
and a &lt;code&gt;template&lt;/code&gt; file (see &lt;em&gt;&lt;code&gt;*.tmpl&lt;/code&gt;&lt;/em&gt; samples &lt;a href=&#34;https://github.com/mllg/batchtools/tree/master/inst/templates&#34;&gt;here&lt;/a&gt;)
for the queueing available on a system. The following example uses the sample
&lt;code&gt;conffile&lt;/code&gt; and &lt;code&gt;template&lt;/code&gt; files for the Slurm scheduler provided by this package.&lt;/p&gt;
&lt;p&gt;The resources can be appended when the step is generated, or it is possible to
add these resources later, as the following example using the &lt;code&gt;addResources&lt;/code&gt;
function:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;resources &amp;lt;- list(conffile=&amp;quot;.batchtools.conf.R&amp;quot;,
                  template=&amp;quot;batchtools.slurm.tmpl&amp;quot;, 
                  Njobs=18, 
                  walltime=120, ## minutes
                  ntasks=1,
                  ncpus=4, 
                  memory=1024, ## Mb
                  partition = &amp;quot;short&amp;quot;
                  )
sal &amp;lt;- addResources(sal, c(&amp;quot;hisat2_mapping&amp;quot;), resources = resources)
sal &amp;lt;- runWF(sal)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;visualize-workflow&#34;&gt;Visualize workflow&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;&lt;code&gt;systemPipeR&lt;/code&gt;&lt;/em&gt; workflows instances can be visualized with the &lt;code&gt;plotWF&lt;/code&gt; function.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;plotWF(sal, rstudio = TRUE)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;checking-workflow-status&#34;&gt;Checking workflow status&lt;/h2&gt;
&lt;p&gt;To check the summary of the workflow, we can use:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;sal
statusWF(sal)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;accessing-logs-report&#34;&gt;Accessing logs report&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;&lt;code&gt;systemPipeR&lt;/code&gt;&lt;/em&gt; compiles all the workflow execution logs in one central location,
making it easier to check any standard output (&lt;code&gt;stdout&lt;/code&gt;) or standard error
(&lt;code&gt;stderr&lt;/code&gt;) for any command-line tools used on the workflow or the R code stdout.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;sal &amp;lt;- renderLogs(sal)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;session-info&#34;&gt;Session Info&lt;/h2&gt;
&lt;p&gt;This is the session information for rendering this report. To access the session information
of workflow running, check HTML report of &lt;code&gt;renderLogs&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;sessionInfo()
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## R version 4.3.0 (2023-04-21)
## Platform: x86_64-pc-linux-gnu (64-bit)
## Running under: Debian GNU/Linux 11 (bullseye)
## 
## Matrix products: default
## BLAS:   /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.9.0 
## LAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.9.0
## 
## locale:
##  [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C              
##  [3] LC_TIME=en_US.UTF-8        LC_COLLATE=en_US.UTF-8    
##  [5] LC_MONETARY=en_US.UTF-8    LC_MESSAGES=en_US.UTF-8   
##  [7] LC_PAPER=en_US.UTF-8       LC_NAME=C                 
##  [9] LC_ADDRESS=C               LC_TELEPHONE=C            
## [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C       
## 
## time zone: America/Los_Angeles
## tzcode source: system (glibc)
## 
## attached base packages:
## [1] stats4    stats     graphics  grDevices utils    
## [6] datasets  methods   base     
## 
## other attached packages:
##  [1] systemPipeR_2.6.0           ShortRead_1.58.0           
##  [3] GenomicAlignments_1.36.0    SummarizedExperiment_1.30.0
##  [5] Biobase_2.60.0              MatrixGenerics_1.12.0      
##  [7] matrixStats_0.63.0          BiocParallel_1.34.0        
##  [9] Rsamtools_2.16.0            Biostrings_2.68.0          
## [11] XVector_0.40.0              GenomicRanges_1.52.0       
## [13] GenomeInfoDb_1.36.0         IRanges_2.34.0             
## [15] S4Vectors_0.38.0            BiocGenerics_0.46.0        
## [17] BiocStyle_2.28.0           
## 
## loaded via a namespace (and not attached):
##  [1] gtable_0.3.3            xfun_0.39              
##  [3] bslib_0.4.2             hwriter_1.3.2.1        
##  [5] ggplot2_3.4.2           htmlwidgets_1.6.2      
##  [7] latticeExtra_0.6-30     lattice_0.21-8         
##  [9] generics_0.1.3          vctrs_0.6.2            
## [11] tools_4.3.0             bitops_1.0-7           
## [13] parallel_4.3.0          tibble_3.2.1           
## [15] fansi_1.0.4             pkgconfig_2.0.3        
## [17] Matrix_1.5-4            RColorBrewer_1.1-3     
## [19] lifecycle_1.0.3         GenomeInfoDbData_1.2.10
## [21] stringr_1.5.0           compiler_4.3.0         
## [23] deldir_1.0-6            munsell_0.5.0          
## [25] codetools_0.2-19        htmltools_0.5.5        
## [27] sass_0.4.5              RCurl_1.98-1.12        
## [29] yaml_2.3.7              pillar_1.9.0           
## [31] crayon_1.5.2            jquerylib_0.1.4        
## [33] DelayedArray_0.25.0     cachem_1.0.7           
## [35] tidyselect_1.2.0        digest_0.6.31          
## [37] stringi_1.7.12          dplyr_1.1.2            
## [39] bookdown_0.33           fastmap_1.1.1          
## [41] grid_4.3.0              colorspace_2.1-0       
## [43] cli_3.6.1               magrittr_2.0.3         
## [45] utf8_1.2.3              scales_1.2.1           
## [47] rmarkdown_2.21          jpeg_0.1-10            
## [49] interp_1.1-4            blogdown_1.16          
## [51] png_0.1-8               evaluate_0.20          
## [53] knitr_1.42              rlang_1.1.1            
## [55] Rcpp_1.0.10             glue_1.6.2             
## [57] formatR_1.14            BiocManager_1.30.20    
## [59] jsonlite_1.8.4          R6_2.5.1               
## [61] zlibbioc_1.46.0
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;funding&#34;&gt;Funding&lt;/h1&gt;
&lt;p&gt;This project is funded by NSF award &lt;a href=&#34;https://www.nsf.gov/awardsearch/showAward?AWD_ID=1661152&#34;&gt;ABI-1661152&lt;/a&gt;.&lt;/p&gt;
&lt;h1 id=&#34;references&#34;&gt;References&lt;/h1&gt;
&lt;div id=&#34;refs&#34; class=&#34;references hanging-indent&#34;&gt;
&lt;div id=&#34;ref-Bolger2014-yr&#34;&gt;
&lt;p&gt;Bolger, Anthony M, Marc Lohse, and Bjoern Usadel. 2014. “Trimmomatic: A Flexible Trimmer for Illumina Sequence Data.” &lt;em&gt;Bioinformatics&lt;/em&gt; 30 (15): 2114–20.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;ref-H_Backman2016-bt&#34;&gt;
&lt;p&gt;H Backman, Tyler W, and Thomas Girke. 2016. “systemPipeR: NGS workflow and report generation environment.” &lt;em&gt;BMC Bioinformatics&lt;/em&gt; 17 (1): 388. &lt;a href=&#34;https://doi.org/10.1186/s12859-016-1241-0&#34;&gt;https://doi.org/10.1186/s12859-016-1241-0&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;ref-Howard2013-fq&#34;&gt;
&lt;p&gt;Howard, Brian E, Qiwen Hu, Ahmet Can Babaoglu, Manan Chandra, Monica Borghi, Xiaoping Tan, Luyan He, et al. 2013. “High-Throughput RNA Sequencing of Pseudomonas-Infected Arabidopsis Reveals Hidden Transcriptome Complexity and Novel Splice Variants.” &lt;em&gt;PLoS One&lt;/em&gt; 8 (10): e74183. &lt;a href=&#34;https://doi.org/10.1371/journal.pone.0074183&#34;&gt;https://doi.org/10.1371/journal.pone.0074183&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;ref-Kim2015-ve&#34;&gt;
&lt;p&gt;Kim, Daehwan, Ben Langmead, and Steven L Salzberg. 2015. “HISAT: A Fast Spliced Aligner with Low Memory Requirements.” &lt;em&gt;Nat. Methods&lt;/em&gt; 12 (4): 357–60.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;ref-Lawrence2013-kt&#34;&gt;
&lt;p&gt;Lawrence, Michael, Wolfgang Huber, Hervé Pagès, Patrick Aboyoun, Marc Carlson, Robert Gentleman, Martin T Morgan, and Vincent J Carey. 2013. “Software for Computing and Annotating Genomic Ranges.” &lt;em&gt;PLoS Comput. Biol.&lt;/em&gt; 9 (8): e1003118. &lt;a href=&#34;https://doi.org/10.1371/journal.pcbi.1003118&#34;&gt;https://doi.org/10.1371/journal.pcbi.1003118&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;ref-Robinson2010-uk&#34;&gt;
&lt;p&gt;Robinson, M D, D J McCarthy, and G K Smyth. 2010. “EdgeR: A Bioconductor Package for Differential Expression Analysis of Digital Gene Expression Data.” &lt;em&gt;Bioinformatics&lt;/em&gt; 26 (1): 139–40. &lt;a href=&#34;https://doi.org/10.1093/bioinformatics/btp616&#34;&gt;https://doi.org/10.1093/bioinformatics/btp616&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

      </description>
    </item>
    
    <item>
      <title>Tutorials: VAR-Seq Workflow Template</title>
      <link>/tutorials/spvarseq/spvarseq/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/tutorials/spvarseq/spvarseq/</guid>
      <description>
        
        
        &lt;style type=&#34;text/css&#34;&gt;
pre code {
white-space: pre !important;
overflow-x: scroll !important;
word-break: keep-all !important;
word-wrap: initial !important;
}
&lt;/style&gt;
&lt;!--
# Compile from command-line
Rscript -e &#34;rmarkdown::render(&#39;spvarseq.Rmd&#39;, c(&#39;BiocStyle::html_document&#39;), clean=FALSE); knitr::knit(&#39;spvarseq.Rmd&#39;, tangle=TRUE)&#34;&#34;
--&gt;
&lt;script type=&#34;text/javascript&#34;&gt;
document.addEventListener(&#34;DOMContentLoaded&#34;, function() {
  document.querySelector(&#34;h1&#34;).className = &#34;title&#34;;
});
&lt;/script&gt;
&lt;script type=&#34;text/javascript&#34;&gt;
document.addEventListener(&#34;DOMContentLoaded&#34;, function() {
  var links = document.links;  
  for (var i = 0, linksLength = links.length; i &lt; linksLength; i++)
    if (links[i].hostname != window.location.hostname)
      links[i].target = &#39;_blank&#39;;
});
&lt;/script&gt;
&lt;div style=&#34;text-align: right&#34;&gt;
&lt;p&gt;Source code download:    
[ &lt;a href=&#34;https://raw.githubusercontent.com/tgirke/GEN242//main/content/en/tutorials/sprnaseq/sprnaseq.Rmd&#34;&gt;.Rmd&lt;/a&gt; ]    
[ &lt;a href=&#34;https://raw.githubusercontent.com/tgirke/GEN242//main/content/en/tutorials/sprnaseq/sprnaseq.R&#34;&gt;.R&lt;/a&gt; ]&lt;/p&gt;
&lt;/div&gt;
&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;
&lt;h3 id=&#34;experimental-design&#34;&gt;Experimental design&lt;/h3&gt;
&lt;p&gt;Typically, users want to specify here all information relevant for the
analysis of their VAR-Seq study. This includes detailed descriptions of
FASTQ files, experimental design, reference genome, gene annotations,
etc.&lt;/p&gt;
&lt;h2 id=&#34;workflow-environment&#34;&gt;Workflow environment&lt;/h2&gt;
&lt;h3 id=&#34;generate-workflow-environment&#34;&gt;Generate workflow environment&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;http://bioconductor.org/packages/release/data/experiment/html/systemPipeRdata.html&#34;&gt;&lt;em&gt;systemPipeRdata&lt;/em&gt;&lt;/a&gt;
package is a helper package to generate a fully populated &lt;a href=&#34;http://bioconductor.org/packages/release/bioc/html/systemPipeR.html&#34;&gt;&lt;em&gt;systemPipeR&lt;/em&gt;&lt;/a&gt;
workflow environment in the current working directory with a single command.
All the instruction for generating the pre-configured workflow templates are provide
in the &lt;a href=&#34;http://www.bioconductor.org/packages/devel/data/experiment/vignettes/systemPipeRdata/inst/doc/systemPipeRdata.html#1_Introduction&#34;&gt;&lt;em&gt;systemPipeRdata&lt;/em&gt; vignette&lt;/a&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;systemPipeRdata::genWorkenvir(workflow = &amp;quot;varseq&amp;quot;, mydirname = &amp;quot;varseq&amp;quot;)
setwd(&amp;quot;varseq&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This step can be skipped if you already have the environment to run the analysis.
If not, you can run it, and it will create the directory structure and populate
all the necessary param and demo data files.&lt;/p&gt;
&lt;p&gt;After building and loading the workflow environment generated by &lt;code&gt;genWorkenvir&lt;/code&gt;
from &lt;code&gt;systemPipeRdata&lt;/code&gt; all data inputs are stored in
a &lt;code&gt;data/&lt;/code&gt; directory and all analysis results will be written to a separate
&lt;code&gt;results/&lt;/code&gt; directory, while the &lt;code&gt;systemPipeVARseq.Rmd&lt;/code&gt; script and the &lt;code&gt;targets&lt;/code&gt;
file are expected to be located in the parent directory. The R session is expected
to run from this parent directory. Additional parameter files are stored under &lt;code&gt;param/&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;To work with real data, users want to organize their own data similarly
and substitute all test data for their own data. To rerun an established
workflow on new data, the initial &lt;code&gt;targets&lt;/code&gt; file along with the corresponding
FASTQ files are usually the only inputs the user needs to provide.&lt;/p&gt;
&lt;p&gt;For more details, please consult the documentation
&lt;a href=&#34;http://www.bioconductor.org/packages/release/bioc/vignettes/systemPipeR/inst/doc/systemPipeR.html&#34;&gt;here&lt;/a&gt;.
More information about the &lt;code&gt;targets&lt;/code&gt; files from &lt;em&gt;systemPipeR&lt;/em&gt; can be found &lt;a href=&#34;http://www.bioconductor.org/packages/release/bioc/vignettes/systemPipeR/inst/doc/systemPipeR.html#42_Structure_of_initial_targets_data&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id=&#34;build-the-workflow-with-a-single-command&#34;&gt;Build the Workflow with a single command&lt;/h3&gt;
&lt;p&gt;This template provides some common steps for a &lt;code&gt;VARseq&lt;/code&gt; workflow. One can add, remove,
modify workflow steps by operating on the &lt;code&gt;SYSargsList&lt;/code&gt; workflow object.
For more details of all the features and utilities, please consult the &lt;a href=&#34;http://www.bioconductor.org/packages/release/bioc/vignettes/systemPipeR/inst/doc/systemPipeR.html&#34;&gt;main vignette&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;To initiate a VARseq workflow, this entire Rmarkdown file will be imported as a
&lt;code&gt;SYSargsList&lt;/code&gt; workflow object, by using the &lt;code&gt;importWF(&amp;quot;systemPipeVARseq.Rmd&amp;quot;)&lt;/code&gt; command.&lt;/p&gt;
&lt;p&gt;In this template, code chunks with the option &lt;code&gt;spr = TRUE&#39;&lt;/code&gt; will be added to the workflow.
Other R code chunks without this option will be ignored. The option &lt;code&gt;eval = FALSE&lt;/code&gt;
can be ignored when imported and build the workflow object. Please be aware of this
possibility.&lt;/p&gt;
&lt;p&gt;The template can provide more than one alternative for each step, such as
different mapping methods, that will receive the &lt;code&gt;mandatory&lt;/code&gt; or &lt;code&gt;optional&lt;/code&gt; flag.
One can run just the &lt;code&gt;mandatory&lt;/code&gt; steps, &lt;code&gt;ALL&lt;/code&gt;, or &lt;code&gt;optional&lt;/code&gt; steps when running
the workflow.&lt;/p&gt;
&lt;p&gt;Also, each one of the steps can be run on compute clusters (&lt;code&gt;compute&lt;/code&gt; option)
or on the current session, here called &lt;code&gt;management&lt;/code&gt; session.
For the demonstration of this template, a &lt;code&gt;management&lt;/code&gt; session will be chosen.&lt;/p&gt;
&lt;h3 id=&#34;workflow-initialization&#34;&gt;Workflow initialization&lt;/h3&gt;
&lt;p&gt;The other alternative is to initialize the workflow and append each of the steps
in the workflow object.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;sal &amp;lt;- SPRproject()
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;required-packages-and-resources&#34;&gt;Required packages and resources&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;&lt;code&gt;systemPipeR&lt;/code&gt;&lt;/em&gt; workflows can be designed and built from start to finish with a
single command, importing from an R Markdown file or stepwise in interactive
mode from the R console.
This tutorial will demonstrate how to build the workflow in an interactive mode,
appending each step. The workflow is constructed by connecting each step via
&lt;code&gt;appendStep&lt;/code&gt; method. Each &lt;code&gt;SYSargsList&lt;/code&gt; instance contains instructions needed
for processing a set of input files with a specific command-line or R software
and the paths to the corresponding outfiles generated by a particular tool/step.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;systemPipeR&lt;/code&gt; package needs to be loaded (H Backman and Girke 2016).&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# Some samples in the test dataset do not work well in
# VARseq, and VARseq workflow takes long time to process
# each sample. To better test and speed up the test
# workflow, sample set is reduced to the first 13 samples.
# Please REMOVE the next two lines in your real analysis
cat(crayon::red$bold(&amp;quot;Some samples in targets are removed for test workflow. Please change the template to disable this in your real analysis.\n&amp;quot;))
writeLines(readLines(&amp;quot;targetsPE.txt&amp;quot;)[1:13], &amp;quot;targetsPE.txt&amp;quot;)

cat(crayon::blue$bold(&amp;quot;To use this workflow, following R packages are expected:\n&amp;quot;))
cat(c(&amp;quot;&#39;GenomicFeatures&amp;quot;, &amp;quot;VariantAnnotation&amp;quot;, &amp;quot;GenomicFeatures&amp;quot;,
    &amp;quot;ggbio&amp;quot;, &amp;quot;ggplot2&#39;\n&amp;quot;), sep = &amp;quot;&#39;, &#39;&amp;quot;)
### pre-end
appendStep(sal) &amp;lt;- LineWise(code = {
    library(systemPipeR)
}, step_name = &amp;quot;load_SPR&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;fastq-quality-report&#34;&gt;FASTQ quality report&lt;/h3&gt;
&lt;p&gt;The following &lt;code&gt;seeFastq&lt;/code&gt; and &lt;code&gt;seeFastqPlot&lt;/code&gt; functions generate and plot a series of useful
quality statistics for a set of FASTQ files including per cycle quality box
plots, base proportions, base-level quality trends, relative k-mer
diversity, length, and occurrence distribution of reads, number of reads
above quality cutoffs and mean quality distribution. The results are
written to a png file named &lt;code&gt;fastqReport.png&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;This is the pre-trimming fastq report. Another post-trimming fastq report step
is not included in the default. It is recommended to run this step first to
decide whether the trimming is needed.&lt;/p&gt;
&lt;p&gt;Please note that initial targets files are being used here. In this case,
it has been added to the first step, and later, we used the function &lt;code&gt;getColumn&lt;/code&gt;
to extract a named vector.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;appendStep(sal) &amp;lt;- LineWise(code = {
    targets &amp;lt;- read.delim(&amp;quot;targetsPE.txt&amp;quot;, comment.char = &amp;quot;#&amp;quot;)
    updateColumn(sal, step = &amp;quot;load_SPR&amp;quot;, position = &amp;quot;targetsWF&amp;quot;) &amp;lt;- targets
    fq_files &amp;lt;- getColumn(sal, &amp;quot;load_SPR&amp;quot;, &amp;quot;targetsWF&amp;quot;, column = 1)
    fqlist &amp;lt;- seeFastq(fastq = fq_files, batchsize = 10000, klength = 8)
    png(&amp;quot;./results/fastqReport.png&amp;quot;, height = 162, width = 288 *
        length(fqlist))
    seeFastqPlot(fqlist)
    dev.off()
}, step_name = &amp;quot;fastq_report_pre&amp;quot;, dependency = &amp;quot;load_SPR&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;../results/fastqReport.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;div data-align=&#34;center&#34;&gt;
&lt;p&gt;Figure 1: FASTQ quality report for 18 samples&lt;/p&gt;
&lt;/div&gt;
&lt;/br&gt;
&lt;h3 id=&#34;read-preprocessing&#34;&gt;Read preprocessing&lt;/h3&gt;
&lt;h4 id=&#34;read-trimming-with-trimmomatic&#34;&gt;Read trimming with Trimmomatic&lt;/h4&gt;
&lt;p&gt;Next, we need to populate the object created with the first step in the
workflow. Here, an example of how to perform this task using parameters template
files for trimming FASTQ files with &lt;a href=&#34;http://www.usadellab.org/cms/?page=trimmomatic&#34;&gt;Trimmomatic&lt;/a&gt;
software (Bolger, Lohse, and Usadel 2014).
For this step, the &lt;code&gt;SYSargsList&lt;/code&gt; function has been used to build the command-line
and append to &lt;code&gt;sal&lt;/code&gt; object. For more details of all the features and utilities,
please consult the &lt;a href=&#34;http://www.bioconductor.org/packages/release/bioc/vignettes/systemPipeR/inst/doc/systemPipeR.html&#34;&gt;main vignette&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;If GATK (default) is used for variant calling, any type of fastq trimming is
strongly depreciated. GATK have internal function to handle low quality posistions.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;appendStep(sal) &amp;lt;- SYSargsList(step_name = &amp;quot;trimmomatic&amp;quot;, targets = &amp;quot;targetsPE.txt&amp;quot;,
    wf_file = &amp;quot;trimmomatic/trimmomatic-pe.cwl&amp;quot;, input_file = &amp;quot;trimmomatic/trimmomatic-pe.yml&amp;quot;,
    dir_path = &amp;quot;param/cwl&amp;quot;, inputvars = c(FileName1 = &amp;quot;_FASTQ_PATH1_&amp;quot;,
        FileName2 = &amp;quot;_FASTQ_PATH2_&amp;quot;, SampleName = &amp;quot;_SampleName_&amp;quot;),
    dependency = c(&amp;quot;fastq_report_pre&amp;quot;), run_step = &amp;quot;optional&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;preprocessing-with-preprocessreads-function&#34;&gt;Preprocessing with &lt;em&gt;&lt;code&gt;preprocessReads&lt;/code&gt;&lt;/em&gt; function&lt;/h4&gt;
&lt;p&gt;The function &lt;em&gt;&lt;code&gt;preprocessReads&lt;/code&gt;&lt;/em&gt; allows to apply predefined or custom
read preprocessing functions to all FASTQ files referenced in a
&lt;em&gt;&lt;code&gt;SYSargsList&lt;/code&gt;&lt;/em&gt; container, such as quality filtering or adaptor trimming
routines. Internally, &lt;em&gt;&lt;code&gt;preprocessReads&lt;/code&gt;&lt;/em&gt; uses the &lt;em&gt;&lt;code&gt;FastqStreamer&lt;/code&gt;&lt;/em&gt; function from
the &lt;em&gt;&lt;code&gt;ShortRead&lt;/code&gt;&lt;/em&gt; package to stream through large FASTQ files in a
memory-efficient manner. The following example performs adaptor trimming with
the &lt;em&gt;&lt;code&gt;trimLRPatterns&lt;/code&gt;&lt;/em&gt; function from the &lt;em&gt;&lt;code&gt;Biostrings&lt;/code&gt;&lt;/em&gt; package.&lt;/p&gt;
&lt;p&gt;Here, we are appending this step at the &lt;em&gt;&lt;code&gt;SYSargsList&lt;/code&gt;&lt;/em&gt; object created previously.
All the parameters are defined on the &lt;em&gt;&lt;code&gt;preprocessReads/preprocessReads-pe.yml&lt;/code&gt;&lt;/em&gt; file.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;appendStep(sal) &amp;lt;- SYSargsList(step_name = &amp;quot;preprocessing&amp;quot;, targets = &amp;quot;targetsPE.txt&amp;quot;,
    dir = TRUE, wf_file = &amp;quot;preprocessReads/preprocessReads-pe.cwl&amp;quot;,
    input_file = &amp;quot;preprocessReads/preprocessReads-pe.yml&amp;quot;, dir_path = &amp;quot;param/cwl&amp;quot;,
    inputvars = c(FileName1 = &amp;quot;_FASTQ_PATH1_&amp;quot;, FileName2 = &amp;quot;_FASTQ_PATH2_&amp;quot;,
        SampleName = &amp;quot;_SampleName_&amp;quot;), dependency = c(&amp;quot;fastq_report_pre&amp;quot;),
    run_step = &amp;quot;optional&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the trimming step, the &lt;code&gt;outfiles&lt;/code&gt; files can be used to generate the new
targets files containing the paths to the trimmed FASTQ files. The new targets
information can be used for the next workflow step instance, &lt;em&gt;e.g.&lt;/em&gt; running the
NGS alignments with the trimmed FASTQ files.&lt;/p&gt;
&lt;p&gt;The following example shows how one can design a custom read &lt;em&gt;‘preprocessReads’&lt;/em&gt;
function using utilities provided by the &lt;em&gt;&lt;code&gt;ShortRead&lt;/code&gt;&lt;/em&gt; package, and then run it
in batch mode with the &lt;em&gt;‘preprocessReads’&lt;/em&gt; function. For here, it is possible to
replace the function used on the &lt;code&gt;preprocessing&lt;/code&gt; step and modify the &lt;code&gt;sal&lt;/code&gt; object.
Because it is a custom function, it is necessary to save the part in the R object,
and internally the &lt;code&gt;preprocessReads.doc.R&lt;/code&gt; is loading the function. If the R object
is saved with a different name (here &lt;code&gt;&amp;quot;param/customFCT.RData&amp;quot;&lt;/code&gt;), please replace
that accordingly in the &lt;code&gt;preprocessReads.doc.R&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Please, note that this step is not added to the workflow, here just for demonstration.&lt;/p&gt;
&lt;p&gt;First, we defined the function in the workflow:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;appendStep(sal) &amp;lt;- LineWise(code = {
    filterFct &amp;lt;- function(fq, cutoff = 20, Nexceptions = 0) {
        qcount &amp;lt;- rowSums(as(quality(fq), &amp;quot;matrix&amp;quot;) &amp;lt;= cutoff,
            na.rm = TRUE)
        # Retains reads where Phred scores are &amp;gt;= cutoff
        # with N exceptions
        fq[qcount &amp;lt;= Nexceptions]
    }
    save(list = ls(), file = &amp;quot;param/customFCT.RData&amp;quot;)
}, step_name = &amp;quot;custom_preprocessing_function&amp;quot;, dependency = &amp;quot;preprocessing&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After, we can edit the input parameter:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;yamlinput(sal, &amp;quot;preprocessing&amp;quot;)$Fct
yamlinput(sal, &amp;quot;preprocessing&amp;quot;, &amp;quot;Fct&amp;quot;) &amp;lt;- &amp;quot;&#39;filterFct(fq, cutoff=20, Nexceptions=0)&#39;&amp;quot;
yamlinput(sal, &amp;quot;preprocessing&amp;quot;)$Fct  ## check the new function
cmdlist(sal, &amp;quot;preprocessing&amp;quot;, targets = 1)  ## check if the command line was updated with success
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;fastq-quality-after-trimming&#34;&gt;FASTQ quality after Trimming&lt;/h3&gt;
&lt;p&gt;This is the post-trimming fastq quality report. If the trimming step is included, it is
recommended to add this step to compare trimming of fastq before and after.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;appendStep(sal) &amp;lt;- LineWise(code = {
    fq_files &amp;lt;- getColumn(sal, &amp;quot;preprocessing&amp;quot;, &amp;quot;outfiles&amp;quot;, column = 1)  ## get outfiles path
    fqlist &amp;lt;- seeFastq(fastq = fq_files, batchsize = 10000, klength = 8)
    png(&amp;quot;./results/fastqReport_pos.png&amp;quot;, height = 18, width = 4 *
        length(fqlist))
    seeFastqPlot(fqlist)
    dev.off()
}, step_name = &amp;quot;fastq_report_pos&amp;quot;, dependency = &amp;quot;trimmomatic&amp;quot;,
    run_step = &amp;quot;optional&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;read-mapping-with-bwa-mem&#34;&gt;Read mapping with &lt;code&gt;BWA-MEM&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;The NGS reads of this project are aligned against the reference genome
sequence using the highly variant tolerant short read aligner &lt;code&gt;BWA-MEM&lt;/code&gt;
(Li 2013; Li and Durbin 2009). The parameter settings of the aligner are
defined in the &lt;code&gt;param/cwl/gatk/bwa-pe.cwl&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;This test code uses untrimmed fastq files since the demo data is minimal and
limited. However, it is best to test with &lt;code&gt;FASTQ quality report&lt;/code&gt; function provided
above to verify your real data first.&lt;/p&gt;
&lt;h4 id=&#34;build-index-and-dictionary-files-for-bwa-and-gatk&#34;&gt;Build index and dictionary files for BWA and GATK&lt;/h4&gt;
&lt;p&gt;Build the index and dictionary files for BWA and GATK to run.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;appendStep(sal) &amp;lt;- SYSargsList(step_name = &amp;quot;bwa_index&amp;quot;, dir = FALSE,
    targets = NULL, wf_file = &amp;quot;gatk/workflow_bwa-index.cwl&amp;quot;,
    input_file = &amp;quot;gatk/gatk.yaml&amp;quot;, dir_path = &amp;quot;param/cwl&amp;quot;, dependency = &amp;quot;load_SPR&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Create reference &lt;code&gt;fasta&lt;/code&gt; dictionary.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;appendStep(sal) &amp;lt;- SYSargsList(step_name = &amp;quot;fasta_index&amp;quot;, dir = FALSE,
    targets = NULL, wf_file = &amp;quot;gatk/workflow_fasta_dict.cwl&amp;quot;,
    input_file = &amp;quot;gatk/gatk.yaml&amp;quot;, dir_path = &amp;quot;param/cwl&amp;quot;, dependency = &amp;quot;bwa_index&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Create dictionary index.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;appendStep(sal) &amp;lt;- SYSargsList(step_name = &amp;quot;faidx_index&amp;quot;, dir = FALSE,
    targets = NULL, wf_file = &amp;quot;gatk/workflow_fasta_faidx.cwl&amp;quot;,
    input_file = &amp;quot;gatk/gatk.yaml&amp;quot;, dir_path = &amp;quot;param/cwl&amp;quot;, dependency = &amp;quot;fasta_index&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;mapping-reads-with-bwa&#34;&gt;Mapping reads with BWA&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;appendStep(sal) &amp;lt;- SYSargsList(step_name = &amp;quot;bwa_alignment&amp;quot;, targets = &amp;quot;targetsPE.txt&amp;quot;,
    wf_file = &amp;quot;gatk/workflow_bwa-pe.cwl&amp;quot;, input_file = &amp;quot;gatk/gatk.yaml&amp;quot;,
    dir_path = &amp;quot;param/cwl&amp;quot;, inputvars = c(FileName1 = &amp;quot;_FASTQ_PATH1_&amp;quot;,
        FileName2 = &amp;quot;_FASTQ_PATH2_&amp;quot;, SampleName = &amp;quot;_SampleName_&amp;quot;),
    dependency = c(&amp;quot;faidx_index&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;read-and-alignment-stats&#34;&gt;Read and alignment stats&lt;/h3&gt;
&lt;p&gt;The following provides an overview of the number of reads in each sample
and how many of them aligned to the reference.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;appendStep(sal) &amp;lt;- LineWise(code = {
    bampaths &amp;lt;- getColumn(sal, step = &amp;quot;bwa_alignment&amp;quot;, &amp;quot;outfiles&amp;quot;,
        column = &amp;quot;samtools_sort_bam&amp;quot;)
    fqpaths &amp;lt;- getColumn(sal, step = &amp;quot;bwa_alignment&amp;quot;, &amp;quot;targetsWF&amp;quot;,
        column = &amp;quot;FileName1&amp;quot;)
    read_statsDF &amp;lt;- alignStats(args = bampaths, fqpaths = fqpaths,
        pairEnd = TRUE)
    write.table(read_statsDF, &amp;quot;results/alignStats.xls&amp;quot;, row.names = FALSE,
        quote = FALSE, sep = &amp;quot;\t&amp;quot;)
}, step_name = &amp;quot;align_stats&amp;quot;, dependency = &amp;quot;bwa_alignment&amp;quot;, run_step = &amp;quot;optional&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;create-symbolic-links-for-viewing-bam-files-in-igv&#34;&gt;Create symbolic links for viewing BAM files in IGV&lt;/h3&gt;
&lt;p&gt;The &lt;code&gt;symLink2bam&lt;/code&gt; function creates symbolic links to view the BAM alignment files in a
genome browser such as IGV. The corresponding URLs are written to a file
with a path specified under &lt;code&gt;urlfile&lt;/code&gt; in the &lt;code&gt;results&lt;/code&gt; directory.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;appendStep(sal) &amp;lt;- LineWise(code = {
    bampaths &amp;lt;- getColumn(sal, step = &amp;quot;bwa_alignment&amp;quot;, &amp;quot;outfiles&amp;quot;,
        column = &amp;quot;samtools_sort_bam&amp;quot;)
    symLink2bam(sysargs = bampaths, htmldir = c(&amp;quot;~/.html/&amp;quot;, &amp;quot;somedir/&amp;quot;),
        urlbase = &amp;quot;http://cluster.hpcc.ucr.edu/~tgirke/&amp;quot;, urlfile = &amp;quot;./results/IGVurl.txt&amp;quot;)
}, step_name = &amp;quot;bam_urls&amp;quot;, dependency = &amp;quot;bwa_alignment&amp;quot;, run_step = &amp;quot;optional&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;variant-calling&#34;&gt;Variant calling&lt;/h3&gt;
&lt;p&gt;The following performs variant calling with &lt;code&gt;GATK&lt;/code&gt; and &lt;code&gt;BCFtools&lt;/code&gt; on a single
machine by &lt;code&gt;runWF&lt;/code&gt; function for each sample sequentially. If a cluster compute
is available, running in parallel mode on a compute cluster can be performed by
&lt;code&gt;runWF&lt;/code&gt;, making available the resources and choose &lt;code&gt;run_session = &amp;quot;compute&amp;quot;&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Not all users have a cluster system, so here to demonstrate an example of variant calling
workflow, only single-machine commands are shown. For cluster jobs, please refer
to our main &lt;a href=&#34;http://www.bioconductor.org/packages/release/bioc/vignettes/systemPipeR/inst/doc/systemPipeR.html&#34;&gt;vignette&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;In addition, the user would choose only one variant caller here rather than
running several ones. However, the workflow manager allows keeping multiple
options available for running the analysis.&lt;/p&gt;
&lt;h4 id=&#34;variant-calling-with-gatk&#34;&gt;Variant calling with &lt;code&gt;GATK&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;The following steps are based on &lt;code&gt;GATK 4.1.1.0&lt;/code&gt; &lt;a href=&#34;https://software.broadinstitute.org/gatk/best-practices/&#34;&gt;Best Practice&lt;/a&gt;.
There are 10 individual steps where the user can choose where to jump in and where to skip.
All scripts are located at &lt;code&gt;param/cwl/gatk&lt;/code&gt;. &lt;code&gt;BQSR&lt;/code&gt; (Base Quality Score Recalibration)
and &lt;code&gt;VQSR&lt;/code&gt; (Variant Quality Score Recalibration) are very specific
to a limited species like human, so this workflow does not support these steps.&lt;/p&gt;
&lt;h4 id=&#34;step1-fastq-to-ubam&#34;&gt;Step1: &lt;code&gt;fastq&lt;/code&gt; to &lt;code&gt;ubam&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;Convert &lt;code&gt;fastq&lt;/code&gt; files to &lt;code&gt;bam&lt;/code&gt; files to prepare for the following step. It is very
important to specific your sequencing platform, default is &lt;code&gt;illumina&lt;/code&gt;. User need
to change &lt;code&gt;param/cwl/gatk/gatk_fastq2ubam.cwl&lt;/code&gt; if the platform is different. Platform information
is needed for the variant caller in later steps to correct calling parameters.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;appendStep(sal) &amp;lt;- SYSargsList(step_name = &amp;quot;fastq2ubam&amp;quot;, targets = &amp;quot;targetsPE.txt&amp;quot;,
    wf_file = &amp;quot;gatk/workflow_gatk_fastq2ubam.cwl&amp;quot;, input_file = &amp;quot;gatk/gatk.yaml&amp;quot;,
    dir_path = &amp;quot;param/cwl&amp;quot;, inputvars = c(FileName1 = &amp;quot;_FASTQ_PATH1_&amp;quot;,
        FileName2 = &amp;quot;_FASTQ_PATH2_&amp;quot;, SampleName = &amp;quot;_SampleName_&amp;quot;),
    dependency = c(&amp;quot;faidx_index&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;step2-merge-bam-and-ubam&#34;&gt;Step2: Merge &lt;code&gt;bam&lt;/code&gt; and &lt;code&gt;ubam&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;This step merges a &lt;code&gt;bam&lt;/code&gt; and &lt;code&gt;ubam&lt;/code&gt; and creates a third &lt;code&gt;bam&lt;/code&gt; file that contains
alignment information and remaining information that was removed by the aligner like &lt;code&gt;BWA&lt;/code&gt;.
The removed information is essential for variant statistics calculation. Previous steps are
recommended, but variant calling can still be performed without these steps.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;appendStep(sal) &amp;lt;- SYSargsList(step_name = &amp;quot;merge_bam&amp;quot;, targets = c(&amp;quot;bwa_alignment&amp;quot;,
    &amp;quot;fastq2ubam&amp;quot;), wf_file = &amp;quot;gatk/workflow_gatk_mergebams.cwl&amp;quot;,
    input_file = &amp;quot;gatk/gatk.yaml&amp;quot;, dir_path = &amp;quot;param/cwl&amp;quot;, inputvars = c(bwa_men_sam = &amp;quot;_bwasam_&amp;quot;,
        ubam = &amp;quot;_ubam_&amp;quot;, SampleName = &amp;quot;_SampleName_&amp;quot;), rm_targets_col = c(&amp;quot;preprocessReads_1&amp;quot;,
        &amp;quot;preprocessReads_2&amp;quot;), dependency = c(&amp;quot;bwa_alignment&amp;quot;,
        &amp;quot;fastq2ubam&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;step3-sort-bam-files-by-genomic-coordinates&#34;&gt;Step3: Sort &lt;code&gt;bam&lt;/code&gt; files by genomic coordinates&lt;/h4&gt;
&lt;p&gt;Sort &lt;code&gt;bam&lt;/code&gt; files by genomic coordinates.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;appendStep(sal) &amp;lt;- SYSargsList(step_name = &amp;quot;sort&amp;quot;, targets = &amp;quot;merge_bam&amp;quot;,
    wf_file = &amp;quot;gatk/workflow_gatk_sort.cwl&amp;quot;, input_file = &amp;quot;gatk/gatk.yaml&amp;quot;,
    dir_path = &amp;quot;param/cwl&amp;quot;, inputvars = c(merge_bam = &amp;quot;_mergebam_&amp;quot;,
        SampleName = &amp;quot;_SampleName_&amp;quot;), rm_targets_col = c(&amp;quot;bwa_men_sam&amp;quot;,
        &amp;quot;ubam&amp;quot;, &amp;quot;SampleName_fastq2ubam&amp;quot;, &amp;quot;Factor_fastq2ubam&amp;quot;,
        &amp;quot;SampleLong_fastq2ubam&amp;quot;, &amp;quot;Experiment_fastq2ubam&amp;quot;, &amp;quot;Date_fastq2ubam&amp;quot;),
    dependency = c(&amp;quot;merge_bam&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;step4-mark-duplicates&#34;&gt;Step4: Mark duplicates&lt;/h4&gt;
&lt;p&gt;Mark PCR artifacts in sequencing. A &lt;code&gt;duplicate_metrics&lt;/code&gt; file will also be produced
by this step, but will not be used for the next step. This file is just for the user
to check duplicates status summary.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;appendStep(sal) &amp;lt;- SYSargsList(step_name = &amp;quot;mark_dup&amp;quot;, targets = &amp;quot;sort&amp;quot;,
    wf_file = &amp;quot;gatk/workflow_gatk_markduplicates.cwl&amp;quot;, input_file = &amp;quot;gatk/gatk.yaml&amp;quot;,
    dir_path = &amp;quot;param/cwl&amp;quot;, inputvars = c(sort_bam = &amp;quot;_sort_&amp;quot;,
        SampleName = &amp;quot;_SampleName_&amp;quot;), rm_targets_col = c(&amp;quot;merge_bam&amp;quot;),
    dependency = c(&amp;quot;sort&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;step5-fixing-tags&#34;&gt;Step5: Fixing tags&lt;/h4&gt;
&lt;p&gt;Takes the &lt;code&gt;bam&lt;/code&gt; from the last step and calculates the NM, MD, and UQ tags.
These tags are important for variant calling and filtering.
This step is recommended but can be skipped.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;appendStep(sal) &amp;lt;- SYSargsList(step_name = &amp;quot;fix_tag&amp;quot;, targets = &amp;quot;mark_dup&amp;quot;,
    wf_file = &amp;quot;gatk/workflow_gatk_fixtag.cwl&amp;quot;, input_file = &amp;quot;gatk/gatk.yaml&amp;quot;,
    dir_path = &amp;quot;param/cwl&amp;quot;, inputvars = c(mark_bam = &amp;quot;_mark_&amp;quot;,
        SampleName = &amp;quot;_SampleName_&amp;quot;), rm_targets_col = c(&amp;quot;sort_bam&amp;quot;),
    dependency = c(&amp;quot;mark_dup&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Up till this step, sample preprocess is done. All analysis ready &lt;code&gt;BAM&lt;/code&gt; files and
their index &lt;code&gt;.bai&lt;/code&gt; files are created. Individual and cohort calling by
&lt;code&gt;HaplotypeCaller&lt;/code&gt; is performed from the next step.&lt;/p&gt;
&lt;h4 id=&#34;step6-haplotypecaller-gvcf&#34;&gt;Step6: HaplotypeCaller &lt;code&gt;gvcf&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;The &lt;code&gt;HaplotypeCaller&lt;/code&gt; is running a &lt;strong&gt;gvcf&lt;/strong&gt; mode in this step. G stands for ‘genomic’.
The file not only contains variant sites information but also non-variant sites information;
thus, at the following step, the cohort caller can use this information to validate the true variants.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;appendStep(sal) &amp;lt;- SYSargsList(step_name = &amp;quot;hap_caller&amp;quot;, targets = &amp;quot;fix_tag&amp;quot;,
    wf_file = &amp;quot;gatk/workflow_gatk_haplotypecaller.cwl&amp;quot;, input_file = &amp;quot;gatk/gatk.yaml&amp;quot;,
    dir_path = &amp;quot;param/cwl&amp;quot;, inputvars = c(fixtag_bam = &amp;quot;_fixed_&amp;quot;,
        SampleName = &amp;quot;_SampleName_&amp;quot;), rm_targets_col = c(&amp;quot;mark_bam&amp;quot;),
    dependency = c(&amp;quot;fix_tag&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;step7-import-all-gvcfs&#34;&gt;Step7: Import all &lt;code&gt;gvcfs&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;It is recommended to import all &lt;strong&gt;gvcfs&lt;/strong&gt; to a
&lt;a href=&#34;https://github.com/Intel-HLS/GenomicsDB/wiki&#34;&gt;TileDB&lt;/a&gt; database for fast cohort
variant calling at the following step. Note: if you are working with non-diploid data,
use &lt;code&gt;CombineGVCFs&lt;/code&gt; function from &lt;code&gt;GATK&lt;/code&gt; and change the &lt;code&gt;gvcf_db_folder&lt;/code&gt; parameter
in &lt;code&gt;param/cwl/gatk/gatk.yaml&lt;/code&gt; to be your combined &lt;strong&gt;gvcf&lt;/strong&gt; file path.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Important&lt;/strong&gt;: Make sure all samples’ &lt;code&gt;*.g.vcf.gz&lt;/code&gt; files are in the results folder,
also the &lt;code&gt;tbi index&lt;/code&gt; files also should be there.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;appendStep(sal) &amp;lt;- SYSargsList(step_name = &amp;quot;import&amp;quot;, targets = NULL,
    dir = FALSE, wf_file = &amp;quot;gatk/workflow_gatk_genomicsDBImport.cwl&amp;quot;,
    input_file = &amp;quot;gatk/gatk.yaml&amp;quot;, dir_path = &amp;quot;param/cwl&amp;quot;, dependency = c(&amp;quot;hap_caller&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;step8-cohort-calling-of-gvcf&#34;&gt;Step8: Cohort calling of &lt;code&gt;gvcf&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;Assess variants by information from all &lt;code&gt;gvcfs&lt;/code&gt;. A collective &lt;code&gt;vcf&lt;/code&gt; called
&lt;code&gt;samples.vcf.gz&lt;/code&gt; is created by default naming.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;appendStep(sal) &amp;lt;- SYSargsList(step_name = &amp;quot;call_variants&amp;quot;, targets = NULL,
    dir = FALSE, wf_file = &amp;quot;gatk/workflow_gatk_genotypeGVCFs.cwl&amp;quot;,
    input_file = &amp;quot;gatk/gatk.yaml&amp;quot;, dir_path = &amp;quot;param/cwl&amp;quot;, dependency = c(&amp;quot;import&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;step9-cohort-hard-filter-variants&#34;&gt;Step9: Cohort hard filter variants&lt;/h4&gt;
&lt;p&gt;Variant Quality Score Recalibration (VQSR) is not included in this workflow.
Variants are hard filtered together.
See this &lt;a href=&#34;https://gatkforums.broadinstitute.org/gatk/discussion/2806/howto-apply-hard-filters-to-a-call-set&#34;&gt;Post&lt;/a&gt; for parameters for hard filtering. Change these settings in &lt;code&gt;param/cwl/gak/gatk_variantFiltration.sh&lt;/code&gt; if needed. VQSR requires a large quantity of
samples to be training data before you can do filtering. Read this
&lt;a href=&#34;https://gatk.broadinstitute.org/hc/en-us/articles/360035531612-Variant-Quality-Score-Recalibration-VQSR-&#34;&gt;post&lt;/a&gt; for more information.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;appendStep(sal) &amp;lt;- SYSargsList(step_name = &amp;quot;filter&amp;quot;, targets = NULL,
    dir = FALSE, wf_file = &amp;quot;gatk/workflow_gatk_variantFiltration.cwl&amp;quot;,
    input_file = &amp;quot;gatk/gatk.yaml&amp;quot;, dir_path = &amp;quot;param/cwl&amp;quot;, dependency = c(&amp;quot;call_variants&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;step10-extract-variant&#34;&gt;Step10: Extract variant&lt;/h4&gt;
&lt;p&gt;After cohort calling, filtering, all variants for all samples are stored in one big file.
Extract variants for each sample and save them separately (only variants that have
passed the filters are stored).&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;appendStep(sal) &amp;lt;- SYSargsList(step_name = &amp;quot;create_vcf&amp;quot;, targets = &amp;quot;hap_caller&amp;quot;,
    wf_file = &amp;quot;gatk/workflow_gatk_select_variant.cwl&amp;quot;, input_file = &amp;quot;gatk/gatk.yaml&amp;quot;,
    dir_path = &amp;quot;param/cwl&amp;quot;, inputvars = c(SampleName = &amp;quot;_SampleName_&amp;quot;),
    dependency = c(&amp;quot;hap_caller&amp;quot;, &amp;quot;filter&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;variant-calling-with-bcftools&#34;&gt;Variant calling with &lt;code&gt;BCFtools&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;Alternative option with &lt;code&gt;BCFtool&lt;/code&gt;:&lt;/p&gt;
&lt;p&gt;The following runs the variant calling with &lt;code&gt;BCFtools&lt;/code&gt;. This tool takes &lt;code&gt;BWA&lt;/code&gt;
aligned &lt;code&gt;BAM&lt;/code&gt; files, sort, mark duplicates by &lt;code&gt;samtools&lt;/code&gt; and finally call variants
by &lt;code&gt;BCFtools&lt;/code&gt;.
&lt;strong&gt;For legacy reasons we keep this option.&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;appendStep(sal) &amp;lt;- SYSargsList(step_name = &amp;quot;create_vcf_BCFtool&amp;quot;,
    targets = &amp;quot;bwa_alignment&amp;quot;, dir = TRUE, wf_file = &amp;quot;workflow-bcftools/workflow_bcftools.cwl&amp;quot;,
    input_file = &amp;quot;workflow-bcftools/bcftools.yml&amp;quot;, dir_path = &amp;quot;param/cwl&amp;quot;,
    inputvars = c(bwa_men_sam = &amp;quot;_bwasam_&amp;quot;, SampleName = &amp;quot;_SampleName_&amp;quot;),
    rm_targets_col = c(&amp;quot;preprocessReads_1&amp;quot;, &amp;quot;preprocessReads_2&amp;quot;),
    dependency = &amp;quot;bwa_alignment&amp;quot;, run_step = &amp;quot;optional&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Variant calling ends here. Downstream analysis starts from the next section.&lt;/p&gt;
&lt;h3 id=&#34;inspect-vcf-file&#34;&gt;Inspect VCF file&lt;/h3&gt;
&lt;p&gt;Scripts of downstream analysis are stored in &lt;code&gt;param/cwl/varseq_downstream&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;optional&lt;/strong&gt;: This step is not included in the default workflow. After successfully
execute the entire workflow, users may load individual vcf files to R for
other analysis like below.&lt;/p&gt;
&lt;p&gt;VCF files can be imported into R with the &lt;code&gt;readVcf&lt;/code&gt; function.
Both &lt;code&gt;VCF&lt;/code&gt; and &lt;code&gt;VRanges&lt;/code&gt; objects provide convenient data structure for
working with variant data (&lt;em&gt;e.g.&lt;/em&gt; SNP quality filtering).&lt;/p&gt;
&lt;p&gt;This step is not included in the default workflow steps, but can be useful to
inspect individual sample’s raw variants.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(VariantAnnotation)
vcf_raw &amp;lt;- getColumn(sal, &amp;quot;create_vcf&amp;quot;)
vcf &amp;lt;- readVcf(vcf_raw[1], &amp;quot;A. thaliana&amp;quot;)
vcf
vr &amp;lt;- as(vcf, &amp;quot;VRanges&amp;quot;)
vr
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;filter-variants&#34;&gt;Filter variants&lt;/h3&gt;
&lt;p&gt;The function &lt;code&gt;filterVars&lt;/code&gt; filters VCF files based on user definable
quality parameters. It sequentially imports each VCF file into R, applies the
filtering on an internally generated &lt;code&gt;VRanges&lt;/code&gt; object and then writes
the results to a new subsetted VCF file. The filter parameters are passed on to
the corresponding argument as a character string. The function applies this
filter to the internally generated &lt;code&gt;VRanges&lt;/code&gt; object using the standard
subsetting syntax for two dimensional objects such as: &lt;code&gt;vr[filter, ]&lt;/code&gt;.&lt;/p&gt;
&lt;h4 id=&#34;filter-variants-called-by-gatk&#34;&gt;Filter variants called by &lt;code&gt;GATK&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;The below example filters for variants that are supported by &lt;code&gt;&amp;gt;=x&lt;/code&gt;
reads and &amp;gt;=80% of them support the called variants. In addition, all
variants need to pass &lt;code&gt;&amp;gt;=x&lt;/code&gt; of the soft filters recorded in the VCF
files generated by GATK. Since the toy data used for this workflow is
very small, the chosen settings are unreasonabley relaxed. A more
reasonable filter setting is given in the line below (here commented
out).&lt;/p&gt;
&lt;p&gt;There is already some cohort filtering in GATK step 10. Some additional hard
filtering is provided here. This step is included here, but in a real analysis,
you may skip this step.&lt;/p&gt;
&lt;p&gt;For real samples, use following filters:
&lt;code&gt;filter &amp;lt;- &amp;quot;totalDepth(vr) &amp;gt;= 20 &amp;amp; (altDepth(vr) / totalDepth(vr) &amp;gt;= 0.8)&amp;quot;&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;appendStep(sal) &amp;lt;- LineWise(code = {
    vcf_raw &amp;lt;- getColumn(sal, &amp;quot;create_vcf&amp;quot;)
    library(VariantAnnotation)
    filter &amp;lt;- &amp;quot;totalDepth(vr) &amp;gt;= 2 &amp;amp; (altDepth(vr) / totalDepth(vr) &amp;gt;= 0.8)&amp;quot;
    vcf_filter &amp;lt;- suppressWarnings(filterVars(vcf_raw, filter,
        organism = &amp;quot;A. thaliana&amp;quot;, out_dir = &amp;quot;results/vcf_filter&amp;quot;))
    # dump the filtered path variable to running
    # enviornment so other sysArg steps can get its values
    updateColumn(sal, &amp;quot;create_vcf&amp;quot;, &amp;quot;outfiles&amp;quot;) &amp;lt;- data.frame(vcf_filter = vcf_filter)
}, step_name = &amp;quot;filter_vcf&amp;quot;, dependency = &amp;quot;create_vcf&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;filter-variants-called-by-bcftools&#34;&gt;Filter variants called by &lt;code&gt;BCFtools&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;The following shows how to filter the VCF files generated by &lt;code&gt;BCFtools&lt;/code&gt; using
similar parameter settings as in the previous filtering of the GATK
results.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;appendStep(sal) &amp;lt;- LineWise(code = {
    vcf_raw &amp;lt;- getColumn(sal, step = &amp;quot;create_vcf_BCFtool&amp;quot;, position = &amp;quot;outfiles&amp;quot;,
        column = &amp;quot;bcftools_call&amp;quot;)
    library(VariantAnnotation)
    filter &amp;lt;- &amp;quot;rowSums(vr) &amp;gt;= 2 &amp;amp; (rowSums(vr[,3:4])/rowSums(vr[,1:4]) &amp;gt;= 0.8)&amp;quot;
    vcf_filter_bcf &amp;lt;- suppressWarnings(filterVars(vcf_raw, filter,
        organism = &amp;quot;A. thaliana&amp;quot;, out_dir = &amp;quot;results/vcf_filter_BCFtools&amp;quot;,
        varcaller = &amp;quot;bcftools&amp;quot;))

    updateColumn(sal, &amp;quot;create_vcf&amp;quot;, &amp;quot;outfiles&amp;quot;) &amp;lt;- data.frame(vcf_filter_bcf = vcf_filter_bcf)
}, step_name = &amp;quot;filter_vcf_BCFtools&amp;quot;, dependency = &amp;quot;create_vcf_BCFtool&amp;quot;,
    run_step = &amp;quot;optional&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Check filtering outcome for one sample&lt;/p&gt;
&lt;p&gt;This mini step can be used to compare &lt;code&gt;vcfs&lt;/code&gt; files before and after filtering.
This can be used once the workflow has been run, and make sure “filter_vcf” is
done, since it is an optional step.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;copyEnvir(sal, &amp;quot;vcf_raw&amp;quot;, globalenv())
copyEnvir(sal, &amp;quot;vcf_filter&amp;quot;, globalenv())
length(as(readVcf(vcf_raw[1], genome = &amp;quot;Ath&amp;quot;), &amp;quot;VRanges&amp;quot;)[, 1])
length(as(readVcf(vcf_filter[1], genome = &amp;quot;Ath&amp;quot;), &amp;quot;VRanges&amp;quot;)[,
    1])
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;annotate-filtered-variants&#34;&gt;Annotate filtered variants&lt;/h3&gt;
&lt;p&gt;The function &lt;code&gt;variantReport&lt;/code&gt; generates a variant report using
utilities provided by the &lt;code&gt;VariantAnnotation&lt;/code&gt; package. The report for
each sample is written to a tabular file containing genomic context annotations
(&lt;em&gt;e.g.&lt;/em&gt; coding or non-coding SNPs, amino acid changes, IDs of affected
genes, etc.) along with confidence statistics for each variant. The CWL
file &lt;code&gt;param/cwl/varseq_downstream/annotate.cwl&lt;/code&gt; defines the paths to the input
and output files which are stored in a &lt;code&gt;SYSargs2&lt;/code&gt; instance.&lt;/p&gt;
&lt;h4 id=&#34;basics-of-annotating-variants&#34;&gt;Basics of annotating variants&lt;/h4&gt;
&lt;p&gt;This step can be run after running the default workflow, not included in the default.&lt;/p&gt;
&lt;p&gt;Variants overlapping with common annotation features can be identified with &lt;code&gt;locateVariants&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(&amp;quot;GenomicFeatures&amp;quot;)
# comment the next line if optional step &#39;filter_vcf&#39; is
# included
vcf_filter &amp;lt;- getColumn(sal, &amp;quot;create_vcf&amp;quot;)
# uncomment the next line if optional step &#39;filter_vcf&#39; is
# included copyEnvir(sal, &#39;vcf_filter&#39;, globalenv())
txdb &amp;lt;- loadDb(&amp;quot;./data/tair10.sqlite&amp;quot;)
vcf &amp;lt;- readVcf(vcf_filter[1], &amp;quot;A. thaliana&amp;quot;)
locateVariants(vcf, txdb, CodingVariants())
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Synonymous/non-synonymous variants of coding sequences are computed by the
&lt;code&gt;predictCoding&lt;/code&gt; function for variants overlapping with coding regions.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;fa &amp;lt;- FaFile(&amp;quot;data/tair10.fasta&amp;quot;)
predictCoding(vcf, txdb, seqSource = fa)
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;annotate-filtered-variants-gatk-or-bcftools&#34;&gt;Annotate filtered variants &lt;code&gt;GATK&lt;/code&gt; or &lt;code&gt;BCFtools&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;required&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;appendStep(sal) &amp;lt;- LineWise(code = {
    # get the filtered vcf path from R running environment
    copyEnvir(sal, &amp;quot;vcf_filter&amp;quot;, globalenv())
    library(&amp;quot;GenomicFeatures&amp;quot;)
    txdb &amp;lt;- loadDb(&amp;quot;./data/tair10.sqlite&amp;quot;)
    fa &amp;lt;- FaFile(&amp;quot;data/tair10.fasta&amp;quot;)
    vcf_anno &amp;lt;- suppressMessages(suppressWarnings(variantReport(vcf_filter,
        txdb = txdb, fa = fa, organism = &amp;quot;A. thaliana&amp;quot;, out_dir = &amp;quot;results/vcf_anno&amp;quot;)))
}, step_name = &amp;quot;annotate_vcf&amp;quot;, dependency = &amp;quot;filter_vcf&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;View annotation result for single sample&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;copyEnvir(sal, &amp;quot;vcf_anno&amp;quot;, globalenv())
read.delim(vcf_anno[1])[38:40, ]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;combine-annotation-results-among-samples&#34;&gt;Combine annotation results among samples&lt;/h3&gt;
&lt;p&gt;To simplify comparisons among samples, the &lt;code&gt;combineVarReports&lt;/code&gt;
function combines all variant annotation reports referenced in a
&lt;code&gt;SYSargs2&lt;/code&gt; instance (here &lt;code&gt;args&lt;/code&gt;). At the same time the function
allows to consider only certain feature types of interest. For instance, the
below setting &lt;code&gt;filtercol=c(Consequence=&amp;quot;nonsynonymous&amp;quot;)&lt;/code&gt; will include
only nonsysynonymous variances listed in the &lt;code&gt;Consequence&lt;/code&gt; column of
the annotation reports. To omit filtering, one can use the setting
&lt;code&gt;filtercol=&amp;quot;All&amp;quot;&lt;/code&gt;.&lt;/p&gt;
&lt;h4 id=&#34;combine-results&#34;&gt;Combine results&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;required&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;appendStep(sal) &amp;lt;- LineWise(code = {
    combineDF &amp;lt;- combineVarReports(vcf_anno, filtercol = c(Consequence = &amp;quot;nonsynonymous&amp;quot;))
    write.table(combineDF, &amp;quot;./results/combineDF_nonsyn.tsv&amp;quot;,
        quote = FALSE, row.names = FALSE, sep = &amp;quot;\t&amp;quot;)
}, step_name = &amp;quot;combine_var&amp;quot;, dependency = &amp;quot;annotate_vcf&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;summary-statistics-of-variants&#34;&gt;Summary statistics of variants&lt;/h3&gt;
&lt;p&gt;The &lt;code&gt;varSummary&lt;/code&gt; function counts the number of variants for each feature type
included in the annotation reports.&lt;/p&gt;
&lt;h3 id=&#34;summary-of-variants&#34;&gt;Summary of variants&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;required&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;appendStep(sal) &amp;lt;- LineWise(code = {
    write.table(varSummary(vcf_anno), &amp;quot;./results/variantStats.tsv&amp;quot;,
        quote = FALSE, col.names = NA, sep = &amp;quot;\t&amp;quot;)
}, step_name = &amp;quot;summary_var&amp;quot;, dependency = &amp;quot;combine_var&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;venn-diagram-of-variants&#34;&gt;Venn diagram of variants&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Optional&lt;/strong&gt; but included in the default&lt;/p&gt;
&lt;p&gt;The venn diagram utilities defined by the &lt;code&gt;systemPipeR&lt;/code&gt; package can be used to
identify common and unique variants reported for different samples
and/or variant callers. The below generates a 3-way venn diagram
comparing 3 samples for each of the two variant callers.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;appendStep(sal) &amp;lt;- LineWise(code = {
    ## make a list of first three samples
    varlist &amp;lt;- sapply(names(vcf_anno[1:3]), function(x) as.character(read.delim(vcf_anno[x])$VARID))
    vennset &amp;lt;- overLapper(varlist, type = &amp;quot;vennsets&amp;quot;)
    png(&amp;quot;./results/vennplot_var.png&amp;quot;)
    vennPlot(list(vennset), mymain = &amp;quot;Venn Plot of First 3 Samples&amp;quot;,
        mysub = &amp;quot;&amp;quot;, colmode = 2, ccol = c(&amp;quot;red&amp;quot;, &amp;quot;blue&amp;quot;))
    dev.off()
}, step_name = &amp;quot;venn_diagram&amp;quot;, dependency = &amp;quot;annotate_vcf&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;../results/vennplot_var.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;div data-align=&#34;center&#34;&gt;
&lt;p&gt;Figure 2: Venn Diagram for 3 samples from GATK and BCFtools&lt;/p&gt;
&lt;/div&gt;
&lt;/br&gt;
&lt;h3 id=&#34;plot-variants-programmatically&#34;&gt;Plot variants programmatically&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Optional&lt;/strong&gt; but included in default&lt;/p&gt;
&lt;p&gt;The following plots a selected variant with &lt;code&gt;ggbio&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;In this example, the input &lt;code&gt;BAM&lt;/code&gt; file is from the &lt;code&gt;GATK&lt;/code&gt; step 5, analysis ready bam.
You can use other aligned &lt;code&gt;BAMs&lt;/code&gt; as well, but make sure they are indexed. The &lt;code&gt;VCF&lt;/code&gt;
file is taken from &lt;code&gt;Inspect VCF file&lt;/code&gt; section or you can load your own vcf.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;appendStep(sal) &amp;lt;- LineWise(code = {
    # get the filtered vcf path from R running environment
    copyEnvir(sal, &amp;quot;vcf_filter&amp;quot;, globalenv())
    library(ggbio)
    library(VariantAnnotation)
    mychr &amp;lt;- &amp;quot;ChrM&amp;quot;
    mystart &amp;lt;- 19000
    myend &amp;lt;- 21000
    bams &amp;lt;- getColumn(sal, &amp;quot;fix_tag&amp;quot;)
    vcf &amp;lt;- suppressWarnings(readVcf(vcf_filter[&amp;quot;M6B&amp;quot;], &amp;quot;A. thaliana&amp;quot;))
    ga &amp;lt;- readGAlignments(bams[&amp;quot;M6B&amp;quot;], use.names = TRUE, param = ScanBamParam(which = GRanges(mychr,
        IRanges(mystart, myend))))
    p1 &amp;lt;- autoplot(ga, geom = &amp;quot;rect&amp;quot;)
    p2 &amp;lt;- autoplot(ga, geom = &amp;quot;line&amp;quot;, stat = &amp;quot;coverage&amp;quot;)
    p3 &amp;lt;- autoplot(vcf[seqnames(vcf) == mychr], type = &amp;quot;fixed&amp;quot;) +
        xlim(mystart, myend) + theme(legend.position = &amp;quot;none&amp;quot;,
        axis.text.y = element_blank(), axis.ticks.y = element_blank())
    p4 &amp;lt;- autoplot(loadDb(&amp;quot;./data/tair10.sqlite&amp;quot;), which = GRanges(mychr,
        IRanges(mystart, myend)), names.expr = &amp;quot;gene_id&amp;quot;)
    p1_4 &amp;lt;- tracks(Reads = p1, Coverage = p2, Variant = p3, Transcripts = p4,
        heights = c(0.3, 0.2, 0.1, 0.35)) + ylab(&amp;quot;&amp;quot;)
    ggbio::ggsave(p1_4, filename = &amp;quot;./results/plot_variant.png&amp;quot;,
        units = &amp;quot;in&amp;quot;)
}, step_name = &amp;quot;plot_variant&amp;quot;, dependency = &amp;quot;filter_vcf&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;../results/plot_variant.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;div data-align=&#34;center&#34;&gt;
&lt;p&gt;Figure 3: Plot variants with programmatically.&lt;/p&gt;
&lt;/div&gt;
&lt;/br&gt;
&lt;h3 id=&#34;workflow-information&#34;&gt;Workflow Information&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;appendStep(sal) &amp;lt;- LineWise(code = {
    sessionInfo()
}, step_name = &amp;quot;sessionInfo&amp;quot;, dependency = &amp;quot;plot_variant&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;running-workflow&#34;&gt;Running workflow&lt;/h2&gt;
&lt;h3 id=&#34;interactive-job-submissions-in-a-single-machine&#34;&gt;Interactive job submissions in a single machine&lt;/h3&gt;
&lt;p&gt;For running the workflow, &lt;code&gt;runWF&lt;/code&gt; function will execute all the steps store in
the workflow container. The execution will be on a single machine without
submitting to a queuing system of a computer cluster.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;sal &amp;lt;- runWF(sal)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;parallelization-on-clusters&#34;&gt;Parallelization on clusters&lt;/h3&gt;
&lt;p&gt;Alternatively, the computation can be greatly accelerated by processing many files
in parallel using several compute nodes of a cluster, where a scheduling/queuing
system is used for load balancing.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;resources&lt;/code&gt; list object provides the number of independent parallel cluster
processes defined under the &lt;code&gt;Njobs&lt;/code&gt; element in the list. The following example
will run 18 processes in parallel using each 4 CPU cores.
If the resources available on a cluster allow running all 18 processes at the
same time, then the shown sample submission will utilize in a total of 72 CPU cores.&lt;/p&gt;
&lt;p&gt;Note, &lt;code&gt;runWF&lt;/code&gt; can be used with most queueing systems as it is based on utilities
from the &lt;code&gt;batchtools&lt;/code&gt; package, which supports the use of template files (&lt;em&gt;&lt;code&gt;*.tmpl&lt;/code&gt;&lt;/em&gt;)
for defining the run parameters of different schedulers. To run the following
code, one needs to have both a &lt;code&gt;conffile&lt;/code&gt; (see &lt;em&gt;&lt;code&gt;.batchtools.conf.R&lt;/code&gt;&lt;/em&gt; samples &lt;a href=&#34;https://mllg.github.io/batchtools/&#34;&gt;here&lt;/a&gt;)
and a &lt;code&gt;template&lt;/code&gt; file (see &lt;em&gt;&lt;code&gt;*.tmpl&lt;/code&gt;&lt;/em&gt; samples &lt;a href=&#34;https://github.com/mllg/batchtools/tree/master/inst/templates&#34;&gt;here&lt;/a&gt;)
for the queueing available on a system. The following example uses the sample
&lt;code&gt;conffile&lt;/code&gt; and &lt;code&gt;template&lt;/code&gt; files for the Slurm scheduler provided by this package.&lt;/p&gt;
&lt;p&gt;The resources can be appended when the step is generated, or it is possible to
add these resources later, as the following example using the &lt;code&gt;addResources&lt;/code&gt;
function:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# wall time in mins, memory in MB
resources &amp;lt;- list(conffile = &amp;quot;.batchtools.conf.R&amp;quot;, template = &amp;quot;batchtools.slurm.tmpl&amp;quot;,
    Njobs = 18, walltime = 120, ntasks = 1, ncpus = 4, memory = 1024,
    partition = &amp;quot;short&amp;quot;)
sal &amp;lt;- addResources(sal, c(&amp;quot;hisat2_mapping&amp;quot;), resources = resources)
sal &amp;lt;- runWF(sal)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;visualize-workflow&#34;&gt;Visualize workflow&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;&lt;code&gt;systemPipeR&lt;/code&gt;&lt;/em&gt; workflows instances can be visualized with the &lt;code&gt;plotWF&lt;/code&gt; function.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;plotWF(sal, rstudio = TRUE)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;checking-workflow-status&#34;&gt;Checking workflow status&lt;/h3&gt;
&lt;p&gt;To check the summary of the workflow, we can use:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;sal
statusWF(sal)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;accessing-logs-report&#34;&gt;Accessing logs report&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;&lt;code&gt;systemPipeR&lt;/code&gt;&lt;/em&gt; compiles all the workflow execution logs in one central location,
making it easier to check any standard output (&lt;code&gt;stdout&lt;/code&gt;) or standard error
(&lt;code&gt;stderr&lt;/code&gt;) for any command-line tools used on the workflow or the R code stdout.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;sal &amp;lt;- renderLogs(sal)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;tools-used&#34;&gt;Tools used&lt;/h3&gt;
&lt;p&gt;To check command-line tools used in this workflow, use &lt;code&gt;listCmdTools&lt;/code&gt;, and use &lt;code&gt;listCmdModules&lt;/code&gt;
to check if you have a modular system.&lt;/p&gt;
&lt;p&gt;The following code will print out tools required in your custom SPR project in the report.
In case you are running the workflow for the first and do not have a project yet, or you
just want to browser this workflow, following code displays the tools required by default.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;if (file.exists(file.path(&amp;quot;.SPRproject&amp;quot;, &amp;quot;SYSargsList.yml&amp;quot;))) {
    local({
        sal &amp;lt;- systemPipeR::SPRproject(resume = TRUE)
        systemPipeR::listCmdTools(sal)
        systemPipeR::listCmdModules(sal)
    })
} else {
    cat(crayon::blue$bold(&amp;quot;Tools and modules required by this workflow are:\n&amp;quot;))
    cat(c(&amp;quot;trimmomatic/0.39&amp;quot;, &amp;quot;samtools/1.14&amp;quot;, &amp;quot;gatk/4.2.0.0&amp;quot;,
        &amp;quot;bcftools/1.15&amp;quot;, &amp;quot;bwa/0.7.17&amp;quot;), sep = &amp;quot;\n&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Tools and modules required by this workflow are:
## trimmomatic/0.39
## samtools/1.14
## gatk/4.2.0.0
## bcftools/1.15
## bwa/0.7.17
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;report-session-info&#34;&gt;Report Session Info&lt;/h3&gt;
&lt;p&gt;This is the session information for rendering this report. To access the session information
of workflow running, check HTML report of &lt;code&gt;renderLogs&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;sessionInfo()
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## R version 4.3.3 (2024-02-29)
## Platform: x86_64-pc-linux-gnu (64-bit)
## Running under: Debian GNU/Linux 11 (bullseye)
## 
## Matrix products: default
## BLAS:   /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.9.0 
## LAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.9.0
## 
## locale:
##  [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C              
##  [3] LC_TIME=en_US.UTF-8        LC_COLLATE=en_US.UTF-8    
##  [5] LC_MONETARY=en_US.UTF-8    LC_MESSAGES=en_US.UTF-8   
##  [7] LC_PAPER=en_US.UTF-8       LC_NAME=C                 
##  [9] LC_ADDRESS=C               LC_TELEPHONE=C            
## [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C       
## 
## time zone: America/Los_Angeles
## tzcode source: system (glibc)
## 
## attached base packages:
## [1] stats4    stats     graphics  grDevices utils    
## [6] datasets  methods   base     
## 
## other attached packages:
##  [1] systemPipeR_2.8.0           ShortRead_1.60.0           
##  [3] GenomicAlignments_1.38.2    SummarizedExperiment_1.32.0
##  [5] Biobase_2.62.0              MatrixGenerics_1.14.0      
##  [7] matrixStats_1.2.0           BiocParallel_1.36.0        
##  [9] Rsamtools_2.18.0            Biostrings_2.70.3          
## [11] XVector_0.42.0              GenomicRanges_1.54.1       
## [13] GenomeInfoDb_1.38.8         IRanges_2.36.0             
## [15] S4Vectors_0.40.2            BiocGenerics_0.48.1        
## [17] BiocStyle_2.30.0           
## 
## loaded via a namespace (and not attached):
##  [1] gtable_0.3.4            xfun_0.43              
##  [3] bslib_0.7.0             hwriter_1.3.2.1        
##  [5] ggplot2_3.5.0           htmlwidgets_1.6.4      
##  [7] latticeExtra_0.6-30     lattice_0.22-6         
##  [9] generics_0.1.3          vctrs_0.6.5            
## [11] tools_4.3.3             bitops_1.0-7           
## [13] parallel_4.3.3          fansi_1.0.6            
## [15] tibble_3.2.1            pkgconfig_2.0.3        
## [17] Matrix_1.6-5            RColorBrewer_1.1-3     
## [19] lifecycle_1.0.4         GenomeInfoDbData_1.2.11
## [21] stringr_1.5.1           compiler_4.3.3         
## [23] deldir_2.0-4            munsell_0.5.0          
## [25] codetools_0.2-19        htmltools_0.5.8        
## [27] sass_0.4.9              RCurl_1.98-1.14        
## [29] yaml_2.3.8              pillar_1.9.0           
## [31] crayon_1.5.2            jquerylib_0.1.4        
## [33] DelayedArray_0.28.0     cachem_1.0.8           
## [35] abind_1.4-5             tidyselect_1.2.1       
## [37] digest_0.6.35           stringi_1.8.3          
## [39] dplyr_1.1.4             bookdown_0.38          
## [41] fastmap_1.1.1           grid_4.3.3             
## [43] colorspace_2.1-0        cli_3.6.2              
## [45] SparseArray_1.2.4       magrittr_2.0.3         
## [47] S4Arrays_1.2.1          utf8_1.2.4             
## [49] scales_1.3.0            rmarkdown_2.26         
## [51] jpeg_0.1-10             interp_1.1-6           
## [53] blogdown_1.19           png_0.1-8              
## [55] evaluate_0.23           knitr_1.45             
## [57] rlang_1.1.3             Rcpp_1.0.12            
## [59] glue_1.7.0              formatR_1.14           
## [61] BiocManager_1.30.22     jsonlite_1.8.8         
## [63] R6_2.5.1                zlibbioc_1.48.2
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;funding&#34;&gt;Funding&lt;/h2&gt;
&lt;p&gt;This project was supported by funds from the National Institutes of
Health (NIH) and the National Science Foundation (NSF).&lt;/p&gt;
&lt;h2 id=&#34;references&#34;&gt;References&lt;/h2&gt;
&lt;div id=&#34;refs&#34; class=&#34;references hanging-indent&#34;&gt;
&lt;div id=&#34;ref-Bolger2014-yr&#34;&gt;
&lt;p&gt;Bolger, Anthony M, Marc Lohse, and Bjoern Usadel. 2014. “Trimmomatic: A Flexible Trimmer for Illumina Sequence Data.” &lt;em&gt;Bioinformatics&lt;/em&gt; 30 (15): 2114–20.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;ref-H_Backman2016-bt&#34;&gt;
&lt;p&gt;H Backman, Tyler W, and Thomas Girke. 2016. “systemPipeR: NGS workflow and report generation environment.” &lt;em&gt;BMC Bioinformatics&lt;/em&gt; 17 (1): 388. &lt;a href=&#34;https://doi.org/10.1186/s12859-016-1241-0&#34;&gt;https://doi.org/10.1186/s12859-016-1241-0&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;ref-Li2009-oc&#34;&gt;
&lt;p&gt;Li, H, and R Durbin. 2009. “Fast and Accurate Short Read Alignment with Burrows-Wheeler Transform.” &lt;em&gt;Bioinformatics&lt;/em&gt; 25 (14): 1754–60. &lt;a href=&#34;https://doi.org/10.1093/bioinformatics/btp324&#34;&gt;https://doi.org/10.1093/bioinformatics/btp324&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;ref-Li2013-oy&#34;&gt;
&lt;p&gt;Li, Heng. 2013. “Aligning Sequence Reads, Clone Sequences and Assembly Contigs with BWA-MEM.” &lt;em&gt;arXiv [Q-bio.GN]&lt;/em&gt;, March. &lt;a href=&#34;http://arxiv.org/abs/1303.3997&#34;&gt;http://arxiv.org/abs/1303.3997&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

      </description>
    </item>
    
  </channel>
</rss>
